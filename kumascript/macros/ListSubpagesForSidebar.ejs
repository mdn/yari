<%
// Inserts a tree of subpages of the specified page to be used in the sidebar (quicklinks)
// Displays common flags/icons
// Includes the parent page at the top of the list.
//
// Parameters:
//  $0 - The path of the page whose subpages should be listed.
//  $1 - If true, do not put the text in <code></code>.
//  $2 - If true, do add the parent page to the list
//  $3 - Open delimiter: only text after (including) this in the title will be used
//  $4 - Close delimiter: only text before (including) this is used
//
// Examples:
//
// {{ListSubpagesForSidebar("/en-US/docs/Web/API/WebRTC_API", 1)}}
// {{ListSubpagesForSidebar("/en-US/docs/Web/HTML/Element", 0, 0, "<", ">")}}

// If the path ends with a slash, remove it.
const path = $0.replace(/\/$/, '');
const locale = env.locale;
const includeParent = $2 ? true : false;
const startDelim = $3;
const endDelim = $4;

const overview = mdn.localString({
    'en-US': 'Overview',
    'es': 'Generalidades',
    'fr': 'Aperçu',
    'ja': 'の概要',
    'ko': '개요',
    'ru': 'Обзор',
    'zh-CN': '概述',
    'zh-TW': '概述'
});

const parent = await wiki.getPage(path);
const pages = parent.subpages;

// trim english title for sorting
for (const [_, page] of pages.entries()) {
    page.title = trimTitle(page.title);
}
pages.sort((a, b) => a.title.localeCompare(b.title)) // sorted by english title for subpages    

// always keep the parent page on top, so insert it after sorting
if (includeParent && parent.url) {
    pages.unshift({
        ...parent,
        title: overview
    });
}

let output = '';

const containsTag = page.hasTag;
const htmlEscape = kuma.htmlEscape;
const openTag = '<ol>';
const closeTag = '</ol>';
const code = !$1 ? '<code>' : '';
const endcode = !$1 ? '</code>' : '';

const badges = {
    ExperimentalBadge: await template("ExperimentalBadge"),
    NonStandardBadge: await template("NonStandardBadge"),
    DeprecatedBadge: await template("DeprecatedBadge"),
    ObsoleteBadge: await template("ObsoleteBadge"),
}

// Trims the title, returning only the text
// between the start and end delimiter characters.
// Does nothing if both are null or empty.
function trimTitle(title) {
    const startIndex = startDelim ? Math.max(title.indexOf(startDelim), 0) : 0;

    const endIndex = (endDelim ? title.indexOf(endDelim) + 1 : title.length) ||
        title.length; // if endIndex is 0, then use title.length

    return title.substring(startIndex, endIndex);
}

function createLink(item) {
    const url = item.url.replace('en-US', locale);
    let title = htmlEscape(item.title);

    if (locale !== 'en-US') {
        for (const translation of item.translations) {
            if (translation.locale === locale) {
                title = htmlEscape(trimTitle(translation.title));
            }
        }
    }

    const badgeTexts = [];

    if (containsTag(item, 'Experimental')) {
        badgeTexts.push(badges.ExperimentalBadge);
    }

    if (containsTag(item, 'Non-standard') || containsTag(item, 'Non Standard')) {
        badgeTexts.push(badges.NonStandardBadge);
    }

    if (containsTag(item, 'Deprecated')) {
        badgeTexts.push(badges.DeprecatedBadge);
    }

    if (containsTag(item, 'Obsolete')) {
        badgeTexts.push(badges.ObsoleteBadge);
    }

    const result = `<li>${badgeTexts.join('')}<a href="${url}">${code}${title}${endcode}</a></li>`
    return result;
}

if (pages.length) {
    output = `${openTag}${pages.map(createLink).join('')}${closeTag}`;
}
%>
<%- output %>
