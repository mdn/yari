<%

const webRefData = require('@webref/css');
const { definitionSyntax } = require('css-tree');

const slug = env.slug;
const locale = env.locale;

const valueDefinitionUrl = `/${locale}/docs/Web/CSS/Value_definition_syntax`;

// get the contents of webref
const parsedWebRef = await webRefData.listAll();

/*
 * Get *all* webref spec entries that contain this property
 */
function getSpecsForProp(parsedWebRef, propName) {
  const specsForProp = [];
  for (const [shortname, data] of Object.entries(parsedWebRef)) {
    const propNames = Object.keys(data.properties);
    if (propNames.includes(propName)) {
      specsForProp.push(shortname);
    }
  }
  return specsForProp;
}

/*
 * Given one or more specs that define a property, return a single
 * syntax string for the property.
 */
function resolveSyntax(parsedWebRef, propName, specNames) {
  if (specNames.length === 1) {
    return parsedWebRef[specNames[0]].properties[propName].value;
  }
  // If there's more than one spec,
  // assume that one of them is the base spec, which defines `values`,
  // and the others define incremental additions as `newValues`,
  // then concatenate new values on to values to return a single syntax string
  let syntax = '';
  let newSyntaxes = '';
  for (const specName of specNames) {
    const baseValue = parsedWebRef[specName].properties[propName].value;
    if (baseValue) {
      syntax = baseValue;
    }
    const newValues = parsedWebRef[specName].properties[propName].newValues;
    if (newValues) {
      newSyntaxes += ` | ${newValues}`;
    }
  }
  return `${syntax}${newSyntaxes}`;
}

function getPropertySyntax(propertyName, parsedWebRef) {
  let specsForProp = getSpecsForProp(parsedWebRef, propertyName);
  if (specsForProp.length > 1) {
    // filter out specs that end "-n" where n is a number
    specsForProp = specsForProp.filter( specName => !(/-\d+$/.test(specName)) );
  }
  return resolveSyntax(parsedWebRef, propertyName, specsForProp);
}

// get the property name from URL
const propertyName = $0 || slug.split('/').pop().toLowerCase();

// get the syntax for this property
const propertySyntax = getPropertySyntax(propertyName, parsedWebRef);

// get all the value syntaxes
let valuespaces = {};
for (const spec of Object.values(parsedWebRef)) {
  valuespaces = {...valuespaces, ...spec.valuespaces};
}

/**
 * Used for building links and tooltips for parts of the value definition syntax
 */
const syntaxDescriptions = {
  '*': {
    fragment: 'asterisk_',
    tooltip: 'Asterisk: the entity may occur zero, one or several times'
  },
  '+': {
    fragment: 'plus_',
    tooltip: 'Plus: the entity may occur one or several times'
  },
  '?': {
    fragment: 'question_mark_',
    tooltip: 'Question mark: the entity is optional'
  },
  '{}': {
    fragment: 'curly_braces_',
    tooltip: 'Curly braces: encloses two integers defining the minimal and maximal numbers of occurrences of the entity'
  },
  '#': {
    fragment: 'hash_mark_',
    tooltip: 'Hash mark: the entity is repeated one or several times, each occurence separated by a comma'
  },
  '!': {
    fragment: 'exclamation_point_!',
    tooltip: 'Exclamation point: the group must produce at least one value'
  },
  '[]': {
    fragment: 'brackets',
    tooltip: 'Brackets: enclose several entities, combinators, and multipliers to transform them as a single component'
  },
  '|': {
    fragment: 'single_bar',
    tooltip: 'Single bar: exactly one of the entities must be present'
  },
  '||': {
    fragment: 'double_bar',
    tooltip: 'Double bar: one or several of the entities must be present, in any order'
  },
  '&&': {
    fragment: 'double_ampersand',
    tooltip: 'Double ampersand: all of the entities must be present, in any order'
  }
}

/**
 * Determines the markup to generate for a single node.
 */
function renderNode(name, node) {
  switch (node.type) {
    case 'Property': {
      return `<span class="token property">${name}</span>`;
    }
    case 'Type': {
      // encode < and >
      let encoded = name.replaceAll('<', '&lt;');
      encoded = encoded.replaceAll('>', '&gt;');
      // add CSS class: we use "property" because there isn't one for types
      const span = `<span class="token property">${encoded}</span>`;
      // if this type is not included in the synax, link to its dedicated page
      if (valuespaces[name] && valuespaces[name].value) {
        return span;
      } else {
        // the slug does not include the angle brackets
        let slug = name.replaceAll('<', '');
        slug = slug.replaceAll('>', '');
        slug = slug.replace(/\[.*\]/, '')
        return `<a href="/${locale}/docs/Web/CSS/${slug}">${span}</a>`;
      }
    }
    case 'Multiplier': {
      // link to the Value Definition Symtax and provide a tooltip
      let key = name;
      if (name.startsWith('{')) {
        key = '{}';
      }
      const info = syntaxDescriptions[key];
      return `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${name}</a>`;
    }
    case 'Keyword': {
      return `<span class="token keyword">${name}</span>`;
    }
    case 'Function': {
      return `<span class="token function">${name}</span>`;
    }
    case 'Token': {
      if (name === ')') {
        // this is probably a closing bracket
        return `<span class="token function">${name}</span>`;
      }
    }
    case 'Group': {
      // link from brackets to the value definition syntax docs
      const info = syntaxDescriptions['[]'];
      name = name.replace(/^\[/, `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">[</a>`);
      name = name.replace(/\]$/, `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">]</a>`);

      // link from combinators (except " ") to the value definition syntax docs
      if (node.combinator && (node.combinator !== ' ')) {
        const info = syntaxDescriptions[node.combinator];
        // note that we are replacing the combinator surrounded by spaces, like " | "
        name = name.replaceAll(` ${node.combinator} `, ` <a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${node.combinator}</a> `);
      }

      return name;
    }
  }
  return name;
}

/**
 * Generate the markup for every term in a syntax definition,
 * ensuring that the terms are visually aligned
 */
function renderTerms(terms, combinator) {
  let output = '';
  const termArray = [];
  const termTextLengths = [];

  for (const term of terms) {
    // figure out the lengths of the translated terms, without markup
    // this is just so we can align the terms properly
    const termTextLength = definitionSyntax.generate(term).length;
    termTextLengths.push(termTextLength);
    // get the translated terms, with markup
    const termText = definitionSyntax.generate(term, { decorate: renderNode});
    termArray.push(termText);
  }

  let maxTermLength = Math.max(...termTextLengths);

  // write out the translated terms, padding with spaces for alignment
  // and separating terms using their combinator symbol
  for (let i = 0; i < termArray.length; i++) {
    const termText = termArray[i];
    const spaceCount = (maxTermLength + 2) - termTextLengths[i];
    let combinatorText = '';
    if (combinator && combinator !== " ") {
      const info = syntaxDescriptions[combinator];
      // link from combinators (except " ") to the value definition syntax docs
      combinatorText = `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${combinator}</a>`;
    }
    // omit the combinator for the final term
    combinatorText = (i < termArray.length-1 ? combinatorText : '');
    output += `  ${termText}${Array(spaceCount).join(' ')}${combinatorText}<br/>`;
  }

  return output;
}

/**
 * Render the syntax for a single type
 */
function renderSyntax(type, syntax) {
  // write out the name of this type
  const typeName = `&lt;${type}&gt;`;
  let output = `<span class="token property" id="${typeName}">${typeName} = </span><br/>`;

  const ast = definitionSyntax.parse(syntax);
  // if the combinator is ' ', write the complete type syntax in a single line
  if (ast.combinator === ' ') {
    output += renderTerms([ast], ast.combinator);
  } else {
  // otherwise write out each direct child in its own line
    output += renderTerms(ast.terms, ast.combinator);
  }

  return output;
}

/**
 * Get names of all the types in a given set of syntaxes
 */
function getTypesForSyntaxes(syntaxes, constituents) {

  function processNode(node) {
    if (node.type === 'Type' &&
       (constituents.indexOf(node.name) === -1)) {
      constituents.push(node.name);
    }
  }

  for (const syntax of syntaxes) {
    let ast = definitionSyntax.parse(syntax);
    definitionSyntax.walk(ast, processNode);
  }

}

/**
 * Given an item (such as a CSS property), fetch all the types that participate
 * in its formal syntax definition, either directly or transitively.
 */
function getConstituentTypes() {
  const allConstituents = [];
  let oldConstituentsLength = allConstituents.length;
  // get all the types in the top-level syntax
  let constituentSyntaxes = [propertySyntax];
  getTypesForSyntaxes(constituentSyntaxes, allConstituents);

  // while an iteration added more types...
  while (allConstituents.length > oldConstituentsLength) {
    // get the syntaxes for all newly added constituents,
    // and then get the types in those syntaxes
    constituentSyntaxes = [];
    for (let constituent of allConstituents.slice(oldConstituentsLength)) {

      let constituentSyntaxEntry = valuespaces[`<${constituent}>`];

      if (constituentSyntaxEntry && constituentSyntaxEntry.value) {
        constituentSyntaxes.push(constituentSyntaxEntry.value);
      }
    }

    oldConstituentsLength = allConstituents.length;
    getTypesForSyntaxes(constituentSyntaxes, allConstituents);
  }
  return allConstituents;
}

function writeFormalSyntax() {
  let output = '';
  output += '<pre>';
  // write the syntax for the property
  output += renderSyntax(propertyName, propertySyntax);
  output += '<br/>';
  // collect all the constituent types for the property
  const types = getConstituentTypes();

  // and write each one out
  for (const type of types) {
    if (valuespaces[`<${type}>`] && valuespaces[`<${type}>`].value) {
      output += renderSyntax(type, valuespaces[`<${type}>`].value);
      output += '<br/>';
    }
  }

  output += '</pre>';
  return output;
}

const output = writeFormalSyntax();
%>
<%-output%>
