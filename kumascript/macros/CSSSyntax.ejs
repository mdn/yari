<%

const slug = env.slug;
const locale = env.locale;
const name = $0 || slug.split('/').pop().toLowerCase();

/**
 * Populate `properties` and `valuespaces` from webref
 */
const webRefData = require('@webref/css');
const { definitionSyntax } = require('css-tree');

const parsedFiles = await webRefData.listAll();
const allData = Object.values(parsedFiles);

let properties = {};
for (const spec of allData) {
  properties = {...properties, ...spec.properties};
}

let valuespaces = {};
for (const spec of allData) {
  valuespaces = {...valuespaces, ...spec.valuespaces};
}

/**
 * Used for building links and tooltips for multipliers
 */
const multiplierInfo = {
  '*': {
    fragment: 'asterisk_',
    tooltip: 'Asterisk: the entity may occur zero, one or several times'
  },
  '+': {
    fragment: 'plus_',
    tooltip: 'Plus: the entity may occur one or several times'
  },
  '?': {
    fragment: 'question_mark_',
    tooltip: 'Question mark: the entity is optional'
  },
  '{}': {
    fragment: 'curly_braces_',
    tooltip: 'Curly braces: encloses two integers defining the minimal and maximal numbers of occurrences of the entity'
  },
  '#': {
    fragment: 'hash_mark_',
    tooltip: 'Hash mark: the entity is repeated one or several times, each occurence separated by a comma'
  },
  '!': {
    fragment: 'exclamation_point_!',
    tooltip: 'Exclamation point: the group must produce at least one value'
  }
}

/**
 * Determines the markup to generate for a single node.
 */
function renderNode(name, node) {
  switch (node.type) {
    case 'Property': {
      return `<span class="token property">${name}</span>`;
    }
    case 'Type': {
      // encode < and >
      let encoded = name.replaceAll('<', '&lt;');
      encoded = encoded.replaceAll('>', '&gt;');
      // add CSS class: we use "property" because there isn't one for types
      const span = `<span class="token property">${encoded}</span>`;
      // if this type is not included in the synax, link to its dedicated page
      if (valuespaces[name] && valuespaces[name].value) {
        return span;
      }
      return `<a href="/${locale}/docs/Web/CSS/${encoded}">${span}</a>`;
    }
    case 'Multiplier': {
      // link to the Value Definition Symtax and provide a tooltip
      let key = name;
      if (name.startsWith('{')) {
        key = '{}';
      }
      const info = multiplierInfo[key];
      return `<a href="/${locale}/docs/Web/CSS/Value_definition_syntax#${info.fragment}" title="${info.tooltip}">${name}</a>`;
    }
    case 'Keyword': {
      return `<span class="token keyword">${name}</span>`;
    }
    case 'Function': {
      return `<span class="token function">${name}</span>`;
    }
    case 'Token': {
      if (name === ')') {
        // this is probably a closing bracket
        return `<span class="token function">${name}</span>`;
      }
    }
  }
  return name;
}

/**
 * Generate the markup for every term in a syntax definition,
 * ensuring that the terms are visually aligned
 */
function renderTerms(terms, combinator) {
  let output = '';
  const termArray = [];
  const termTextLengths = [];

  for (const term of terms) {
    // figure out the lengths of the translated terms, without markup
    // this is just so we can align the terms properly
    const termTextLength = definitionSyntax.generate(term).length;
    termTextLengths.push(termTextLength);

    // get the translated terms, with markup
    const termText = definitionSyntax.generate(term, { decorate: renderNode});
    termArray.push(termText);
  }

  let maxTermLength = Math.max(...termTextLengths);

  // write out the translated terms, padding with spaces for alignment
  // and separating terms using their combinator symbol
  for (let i = 0; i < termArray.length; i++) {
    const termText = termArray[i];
    const spaceCount = (maxTermLength + 2) - termTextLengths[i];
    // omit the combinator for the final term
    const combinatorText = (i < termArray.length-1 ? combinator : '');
    output += `  ${termText}${Array(spaceCount).join(' ')}${combinatorText}<br/>`;
  }

  return output;
}

/**
 * Render the syntax for a single type
 */
function renderSyntax(type, syntax) {
  // write out the name of this type
  const typeName = `&lt;${type}&gt;`;
  let output = `<span class="token property" id="${typeName}">${typeName} = </span><br/>`;

  const ast = definitionSyntax.parse(syntax);
  // if the combinator is ' ', write the complete type syntax in a single line
  if (ast.combinator === ' ') {
    output += renderTerms([ast], ast.combinator);
  } else {
  // otherwise write out each direct child in its own line
    output += renderTerms(ast.terms, ast.combinator);
  }

  return output;
}

/**
 * Get names of all the types in a given set of syntaxes
 */
function getTypesForSyntaxes(syntaxes, constituents) {

  function processNode(node) {
    if (node.type === 'Type' &&
       (constituents.indexOf(node.name) === -1)) {
      constituents.push(node.name);
    }
  }

  for (const syntax of syntaxes) {
    let ast = definitionSyntax.parse(syntax);
    definitionSyntax.walk(ast, processNode);
  }

}

/**
 * Given an item (such as a CSS property), fetch all the types that participate
 * in its formal syntax definition, either directly or transitively.
 */
function getConstituentTypes(item) {
  const allConstituents = [];
  let oldConstituentsLength = allConstituents.length;
  // get all the types in the top-level syntax
  let constituentSyntaxes = [properties[item].value];
  getTypesForSyntaxes(constituentSyntaxes, allConstituents);

  // while an iteration added more types...
  while (allConstituents.length > oldConstituentsLength) {
    // get the syntaxes for all newly added constituents,
    // and then get the types in those syntaxes
    constituentSyntaxes = [];
    for (let constituent of allConstituents.slice(oldConstituentsLength)) {

      let constituentSyntaxEntry = valuespaces[`<${constituent}>`];

      if (constituentSyntaxEntry && constituentSyntaxEntry.value) {
        constituentSyntaxes.push(constituentSyntaxEntry.value);
      }
    }

    oldConstituentsLength = allConstituents.length;
    getTypesForSyntaxes(constituentSyntaxes, allConstituents);
  }
  return allConstituents;
}

function writeFormalSyntax(item) {
  let output = '';
  output += '<pre>';

  // write the syntax for the property
  output += renderSyntax(item, properties[item].value);
  output += '<br/>';

  // collect all the constituent types for the property
  const types = getConstituentTypes(item);
  // and write each one out
  for (const type of types) {
    if (valuespaces[`<${type}>`] && valuespaces[`<${type}>`].value) {
      output += renderSyntax(type, valuespaces[`<${type}>`].value);
    }
  }

  output += '</pre>';
  return output;
}

let output = writeFormalSyntax(name);
%>
<%-output%>
