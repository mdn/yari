<%

const webRefData = require('@webref/css');
const { definitionSyntax } = require('css-tree');
const replaceAll = require('string.prototype.replaceall');

const locale = env.locale;

// URL where we describe value definition syntax
const valueDefinitionUrl = `/${locale}/docs/Web/CSS/Value_definition_syntax`;

// Used for building links and tooltips for parts of the value definition syntax
const syntaxDescriptions = {
  '*': {
    fragment: 'asterisk_',
    tooltip: 'Asterisk: the entity may occur zero, one or several times'
  },
  '+': {
    fragment: 'plus_',
    tooltip: 'Plus: the entity may occur one or several times'
  },
  '?': {
    fragment: 'question_mark_',
    tooltip: 'Question mark: the entity is optional'
  },
  '{}': {
    fragment: 'curly_braces_',
    tooltip: 'Curly braces: encloses two integers defining the minimal and maximal numbers of occurrences of the entity'
  },
  '#': {
    fragment: 'hash_mark_',
    tooltip: 'Hash mark: the entity is repeated one or several times, each occurence separated by a comma'
  },
  '!': {
    fragment: 'exclamation_point_!',
    tooltip: 'Exclamation point: the group must produce at least one value'
  },
  '[]': {
    fragment: 'brackets',
    tooltip: 'Brackets: enclose several entities, combinators, and multipliers to transform them as a single component'
  },
  '|': {
    fragment: 'single_bar',
    tooltip: 'Single bar: exactly one of the entities must be present'
  },
  '||': {
    fragment: 'double_bar',
    tooltip: 'Double bar: one or several of the entities must be present, in any order'
  },
  '&&': {
    fragment: 'double_ampersand',
    tooltip: 'Double ampersand: all of the entities must be present, in any order'
  }
}

// get the contents of webref
const parsedWebRef = await webRefData.listAll();

// get all the value syntaxes
let valuespaces = {};
for (const spec of Object.values(parsedWebRef)) {
  valuespaces = {...valuespaces, ...spec.valuespaces};
}

// get the property name from the page slug
const propertyName = $0 || env.slug.split('/').pop().toLowerCase();

/**
 * Get the formal syntax for a property from the webref data, given:
 * @param {string} propertyName - the name of the property
 * @param {object} parsedWebRef - the webref data
 */
function getPropertySyntax(propertyName) {
  // 1) get all specs which list this property
  let specsForProp = [];
  for (const [shortname, data] of Object.entries(parsedWebRef)) {
    const propNames = Object.keys(data.properties);
    if (propNames.includes(propertyName)) {
      specsForProp.push(shortname);
    }
  }
  // 2) If we have more than one spec, filter out specs that end "-n" where n is a number
  if (specsForProp.length > 1) {
    specsForProp = specsForProp.filter( specName => !(/-\d+$/.test(specName)) );
  }
  // 3) If we now have only one spec, return the syntax it lists
  if (specsForProp.length === 1) {
    return parsedWebRef[specsForProp[0]].properties[propertyName].value;
  }
  // 4) If we still have > 1 spec, assume that:
  // - one of them is the base spec, which defines `values`,
  // - the others define incremental additions as `newValues`
  // Concatenate new values on to values to return a single syntax string
  let syntax = '';
  let newSyntaxes = '';
  for (const specName of specsForProp) {
    const baseValue = parsedWebRef[specName].properties[propertyName].value;
    if (baseValue) {
      syntax = baseValue;
    }
    const newValues = parsedWebRef[specName].properties[propertyName].newValues;
    if (newValues) {
      newSyntaxes += ` | ${newValues}`;
    }
  }
  return syntax;
}

/**
 * Determines the markup to generate for a single node in the AST
 * generated by css-tree.
 */
function renderNode(node, name) {
  switch (node.type) {
    case 'Property': {
      return `<span class="token property">${name}</span>`;
    }
    case 'Type': {
      // encode < and >
      let encoded = replaceAll(name, '<', '&lt;');
      encoded = replaceAll(encoded, '>', '&gt;');
      // add CSS class: we use "property" because there isn't one for types
      const span = `<span class="token property">${encoded}</span>`;
      // if this type is not included in the syntax, link to its dedicated page
      if (valuespaces[name] && valuespaces[name].value) {
        return span;
      } else {
        // the slug does not include the angle brackets
        let slug = replaceAll(name, '<', '');
        slug = replaceAll(slug, '>', '');
        slug = slug.replace(/\[.*\]/, '')
        return `<a href="/${locale}/docs/Web/CSS/${slug}">${span}</a>`;
      }
    }
    case 'Multiplier': {
      // link to the Value Definition Symtax and provide a tooltip
      let key = name;
      if (name.startsWith('{')) {
        key = '{}';
      }
      const info = syntaxDescriptions[key];
      return `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${name}</a>`;
    }
    case 'Keyword': {
      return `<span class="token keyword">${name}</span>`;
    }
    case 'Function': {
      return `<span class="token function">${name}</span>`;
    }
    case 'Token': {
      if (name === ')') {
        // this is probably a closing bracket
        return `<span class="token function">${name}</span>`;
      }
    }
    case 'Group': {
      // link from brackets to the value definition syntax docs
      const info = syntaxDescriptions['[]'];
      name = name.replace(/^\[/, `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">[</a>`);
      name = name.replace(/\]$/, `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">]</a>`);

      // link from combinators (except " ") to the value definition syntax docs
      if (node.combinator && (node.combinator !== ' ')) {
        const info = syntaxDescriptions[node.combinator];
        // note that we are replacing the combinator surrounded by spaces, like " | "
        name = replaceAll(name, ` ${node.combinator} `, ` <a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${node.combinator}</a> `);
      }

      return name;
    }
    default:
      return name;
  }
}

/**
 * Generate the markup for every term in a syntax definition,
 * ensuring that the terms are visually aligned
 */
function renderTerms(terms, combinator) {
  let output = '';
  const termArray = [];
  const termTextLengths = [];

  for (const term of terms) {
    // figure out the lengths of the translated terms, without markup
    // this is just so we can align the terms properly
    const termTextLength = definitionSyntax.generate(term).length;
    termTextLengths.push(termTextLength);
    // get the translated terms, with markup
    const termText = definitionSyntax.generate(term, { decorate: renderNode});
    termArray.push(termText);
  }

  const maxTermLength = Math.max(...termTextLengths);

  // write out the translated terms, padding with spaces for alignment
  // and separating terms using their combinator symbol
  for (let i = 0; i < termArray.length; i++) {
    const termText = termArray[i];
    const spaceCount = (maxTermLength + 2) - termTextLengths[i];
    let combinatorText = '';
    if (combinator && combinator !== " ") {
      const info = syntaxDescriptions[combinator];
      // link from combinators (except " ") to the value definition syntax docs
      combinatorText = `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${combinator}</a>`;
    }
    // omit the combinator for the final term
    combinatorText = (i < termArray.length-1 ? combinatorText : '');
    output += `  ${termText}${' '.repeat(spaceCount)}${combinatorText}<br/>`;
  }

  return output;
}

/**
 * Render the syntax for a single type.
 */
function renderSyntax(type, syntax) {
  // write out the name of this type
  let output = `<span class="token property" id="${type}">${type} = </span><br/>`;

  const ast = definitionSyntax.parse(syntax);
  // if the combinator is ' ', write the complete type syntax in a single line
  if (ast.combinator === ' ') {
    output += renderTerms([ast], ast.combinator);
  } else {
  // otherwise write out each direct child in its own line
    output += renderTerms(ast.terms, ast.combinator);
  }

  return output;
}

/**
 * Get names of all the types in a given set of syntaxes
 */
function getTypesForSyntaxes(syntaxes, constituents) {

  function processNode(node) {
    if (node.type === 'Type' &&
       (!constituents.includes(node.name))) {
      constituents.push(node.name);
    }
  }

  for (const syntax of syntaxes) {
    let ast = definitionSyntax.parse(syntax);
    definitionSyntax.walk(ast, processNode);
  }

}

/**
 * Given an item (such as a CSS property), fetch all the types that participate
 * in its formal syntax definition, either directly or transitively.
 */
function getConstituentTypes(propertySyntax) {
  const allConstituents = [];
  let oldConstituentsLength = 0;
  // get all the types in the top-level syntax
  let constituentSyntaxes = [propertySyntax];

  // while an iteration added more types...
  while (true) {
    oldConstituentsLength = allConstituents.length;
    getTypesForSyntaxes(constituentSyntaxes, allConstituents);
  
    if (allConstituents.length <= oldConstituentsLength) {
      break;
    }
    // get the syntaxes for all newly added constituents,
    // and then get the types in those syntaxes
    constituentSyntaxes = [];
    for (let constituent of allConstituents.slice(oldConstituentsLength)) {

      let constituentSyntaxEntry = valuespaces[`<${constituent}>`];

      if (constituentSyntaxEntry && constituentSyntaxEntry.value) {
        constituentSyntaxes.push(constituentSyntaxEntry.value);
      }
    }
  }
  return allConstituents;
}

/**
 * Write out the complete formal syntax for a property.
 *
 * This includes the property's own syntax, described in `propertySyntax`,
 * and also the syntax for any types that participate in the definition of
 * the property.
 */
function writeFormalSyntax(propertySyntax) {
  let output = '';
  output += '<pre>';
  // write the syntax for the property
  output += renderSyntax(propertyName, propertySyntax);
  output += '<br/>';
  // collect all the constituent types for the property
  const types = getConstituentTypes(propertySyntax);

  // and write each one out
  for (const type of types) {
    if (valuespaces[`<${type}>`] && valuespaces[`<${type}>`].value) {
      output += renderSyntax(`&lt;${type}&gt;`, valuespaces[`<${type}>`].value);
      output += '<br/>';
    }
  }

  output += '</pre>';
  return output;
}

let output = '';

// get the syntax for this property
const propertySyntax = getPropertySyntax(propertyName, parsedWebRef);

if (!propertySyntax) {
  output = 'Error: could not find syntax for this item';
} else {
  // write it out
  output = writeFormalSyntax(propertySyntax);
}
%>
<%-output%>
