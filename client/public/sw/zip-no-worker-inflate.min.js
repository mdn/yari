!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? t(exports)
    : "function" == typeof define && define.amd
    ? define(["exports"], t)
    : t(
        ((e = "undefined" != typeof globalThis ? globalThis : e || self).zip =
          {})
      );
})(this, function (e) {
  "use strict";
  const t = -2,
    n = -3,
    i = -5,
    r = [
      0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383,
      32767, 65535,
    ],
    a = [
      96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8,
      48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8,
      128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7,
      59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9,
      176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8,
      20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0,
      8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80,
      7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9,
      216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8,
      76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8,
      114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8,
      2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9,
      148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0,
      8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0,
      8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81,
      7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9,
      236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8,
      62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8,
      142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82,
      7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0,
      9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8,
      25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8,
      105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7,
      4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9,
      202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8,
      69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8,
      125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8,
      13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8,
      195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8,
      35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8,
      91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7,
      19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9,
      246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8,
      55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8,
      135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7,
      99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9,
      190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8,
      16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0,
      8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80,
      7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9,
      209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8,
      72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8,
      116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8,
      4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9,
      153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0,
      8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0,
      8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197,
      81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0,
      9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0,
      8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0,
      8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83,
      7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0,
      9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8,
      30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8,
      110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7,
      256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9,
      195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8,
      65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8,
      121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8,
      9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8,
      258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0,
      8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8,
      93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7,
      23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9,
      251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8,
      51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8,
      131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7,
      67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9,
      183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8,
      23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8,
      103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7,
      9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9,
      223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8,
      79, 0, 9, 255,
    ],
    s = [
      80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85,
      5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5,
      9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5,
      25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4,
      88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193,
      192, 5, 24577,
    ],
    o = [
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ],
    c = [
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
      5, 5, 5, 0, 112, 112,
    ],
    l = [
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,
    ],
    d = [
      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
      11, 11, 12, 12, 13, 13,
    ],
    u = 15;
  function f() {
    let e, t, r, a, s, f;
    function h(e, t, o, c, l, d, h, _, w, p, b) {
      let g, y, x, m, k, v, A, R, U, E, S, z, D, T, F;
      (E = 0), (k = o);
      do {
        r[e[t + E]]++, E++, k--;
      } while (0 !== k);
      if (r[0] == o) return (h[0] = -1), (_[0] = 0), 0;
      for (R = _[0], v = 1; v <= u && 0 === r[v]; v++);
      for (A = v, R < v && (R = v), k = u; 0 !== k && 0 === r[k]; k--);
      for (x = k, R > k && (R = k), _[0] = R, T = 1 << v; v < k; v++, T <<= 1)
        if ((T -= r[v]) < 0) return n;
      if ((T -= r[k]) < 0) return n;
      for (r[k] += T, f[1] = v = 0, E = 1, D = 2; 0 != --k; )
        (f[D] = v += r[E]), D++, E++;
      (k = 0), (E = 0);
      do {
        0 !== (v = e[t + E]) && (b[f[v]++] = k), E++;
      } while (++k < o);
      for (
        o = f[x], f[0] = k = 0, E = 0, m = -1, z = -R, s[0] = 0, S = 0, F = 0;
        A <= x;
        A++
      )
        for (g = r[A]; 0 != g--; ) {
          for (; A > z + R; ) {
            if (
              (m++,
              (z += R),
              (F = x - z),
              (F = F > R ? R : F),
              (y = 1 << (v = A - z)) > g + 1 && ((y -= g + 1), (D = A), v < F))
            )
              for (; ++v < F && !((y <<= 1) <= r[++D]); ) y -= r[D];
            if (((F = 1 << v), p[0] + F > 1440)) return n;
            (s[m] = S = p[0]),
              (p[0] += F),
              0 !== m
                ? ((f[m] = k),
                  (a[0] = v),
                  (a[1] = R),
                  (v = k >>> (z - R)),
                  (a[2] = S - s[m - 1] - v),
                  w.set(a, 3 * (s[m - 1] + v)))
                : (h[0] = S);
          }
          for (
            a[1] = A - z,
              E >= o
                ? (a[0] = 192)
                : b[E] < c
                ? ((a[0] = b[E] < 256 ? 0 : 96), (a[2] = b[E++]))
                : ((a[0] = d[b[E] - c] + 16 + 64), (a[2] = l[b[E++] - c])),
              y = 1 << (A - z),
              v = k >>> z;
            v < F;
            v += y
          )
            w.set(a, 3 * (S + v));
          for (v = 1 << (A - 1); 0 != (k & v); v >>>= 1) k ^= v;
          for (k ^= v, U = (1 << z) - 1; (k & U) != f[m]; )
            m--, (z -= R), (U = (1 << z) - 1);
        }
      return 0 !== T && 1 != x ? i : 0;
    }
    function _(n) {
      let i;
      for (
        e ||
          ((e = []),
          (t = []),
          (r = new Int32Array(16)),
          (a = []),
          (s = new Int32Array(u)),
          (f = new Int32Array(16))),
          t.length < n && (t = []),
          i = 0;
        i < n;
        i++
      )
        t[i] = 0;
      for (i = 0; i < 16; i++) r[i] = 0;
      for (i = 0; i < 3; i++) a[i] = 0;
      s.set(r.subarray(0, u), 0), f.set(r.subarray(0, 16), 0);
    }
    (this.inflate_trees_bits = function (r, a, s, o, c) {
      let l;
      return (
        _(19),
        (e[0] = 0),
        (l = h(r, 0, 19, 19, null, null, s, a, o, e, t)),
        l == n
          ? (c.msg = "oversubscribed dynamic bit lengths tree")
          : (l != i && 0 !== a[0]) ||
            ((c.msg = "incomplete dynamic bit lengths tree"), (l = n)),
        l
      );
    }),
      (this.inflate_trees_dynamic = function (r, a, s, u, f, w, p, b, g) {
        let y;
        return (
          _(288),
          (e[0] = 0),
          (y = h(s, 0, r, 257, o, c, w, u, b, e, t)),
          0 != y || 0 === u[0]
            ? (y == n
                ? (g.msg = "oversubscribed literal/length tree")
                : -4 != y &&
                  ((g.msg = "incomplete literal/length tree"), (y = n)),
              y)
            : (_(288),
              (y = h(s, r, a, 0, l, d, p, f, b, e, t)),
              0 != y || (0 === f[0] && r > 257)
                ? (y == n
                    ? (g.msg = "oversubscribed distance tree")
                    : y == i
                    ? ((g.msg = "incomplete distance tree"), (y = n))
                    : -4 != y &&
                      ((g.msg = "empty distance tree with lengths"), (y = n)),
                  y)
                : 0)
        );
      });
  }
  f.inflate_trees_fixed = function (e, t, n, i) {
    return (e[0] = 9), (t[0] = 5), (n[0] = a), (i[0] = s), 0;
  };
  function h() {
    const e = this;
    let i,
      a,
      s,
      o,
      c = 0,
      l = 0,
      d = 0,
      u = 0,
      f = 0,
      h = 0,
      _ = 0,
      w = 0,
      p = 0,
      b = 0;
    function g(e, t, i, a, s, o, c, l) {
      let d, u, f, h, _, w, p, b, g, y, x, m, k, v, A, R;
      (p = l.next_in_index),
        (b = l.avail_in),
        (_ = c.bitb),
        (w = c.bitk),
        (g = c.write),
        (y = g < c.read ? c.read - g - 1 : c.end - g),
        (x = r[e]),
        (m = r[t]);
      do {
        for (; w < 20; ) b--, (_ |= (255 & l.read_byte(p++)) << w), (w += 8);
        if (
          ((d = _ & x), (u = i), (f = a), (R = 3 * (f + d)), 0 !== (h = u[R]))
        )
          for (;;) {
            if (((_ >>= u[R + 1]), (w -= u[R + 1]), 0 != (16 & h))) {
              for (
                h &= 15, k = u[R + 2] + (_ & r[h]), _ >>= h, w -= h;
                w < 15;

              )
                b--, (_ |= (255 & l.read_byte(p++)) << w), (w += 8);
              for (d = _ & m, u = s, f = o, R = 3 * (f + d), h = u[R]; ; ) {
                if (((_ >>= u[R + 1]), (w -= u[R + 1]), 0 != (16 & h))) {
                  for (h &= 15; w < h; )
                    b--, (_ |= (255 & l.read_byte(p++)) << w), (w += 8);
                  if (
                    ((v = u[R + 2] + (_ & r[h])),
                    (_ >>= h),
                    (w -= h),
                    (y -= k),
                    g >= v)
                  )
                    (A = g - v),
                      g - A > 0 && 2 > g - A
                        ? ((c.window[g++] = c.window[A++]),
                          (c.window[g++] = c.window[A++]),
                          (k -= 2))
                        : (c.window.set(c.window.subarray(A, A + 2), g),
                          (g += 2),
                          (A += 2),
                          (k -= 2));
                  else {
                    A = g - v;
                    do {
                      A += c.end;
                    } while (A < 0);
                    if (((h = c.end - A), k > h)) {
                      if (((k -= h), g - A > 0 && h > g - A))
                        do {
                          c.window[g++] = c.window[A++];
                        } while (0 != --h);
                      else
                        c.window.set(c.window.subarray(A, A + h), g),
                          (g += h),
                          (A += h),
                          (h = 0);
                      A = 0;
                    }
                  }
                  if (g - A > 0 && k > g - A)
                    do {
                      c.window[g++] = c.window[A++];
                    } while (0 != --k);
                  else
                    c.window.set(c.window.subarray(A, A + k), g),
                      (g += k),
                      (A += k),
                      (k = 0);
                  break;
                }
                if (0 != (64 & h))
                  return (
                    (l.msg = "invalid distance code"),
                    (k = l.avail_in - b),
                    (k = w >> 3 < k ? w >> 3 : k),
                    (b += k),
                    (p -= k),
                    (w -= k << 3),
                    (c.bitb = _),
                    (c.bitk = w),
                    (l.avail_in = b),
                    (l.total_in += p - l.next_in_index),
                    (l.next_in_index = p),
                    (c.write = g),
                    n
                  );
                (d += u[R + 2]), (d += _ & r[h]), (R = 3 * (f + d)), (h = u[R]);
              }
              break;
            }
            if (0 != (64 & h))
              return 0 != (32 & h)
                ? ((k = l.avail_in - b),
                  (k = w >> 3 < k ? w >> 3 : k),
                  (b += k),
                  (p -= k),
                  (w -= k << 3),
                  (c.bitb = _),
                  (c.bitk = w),
                  (l.avail_in = b),
                  (l.total_in += p - l.next_in_index),
                  (l.next_in_index = p),
                  (c.write = g),
                  1)
                : ((l.msg = "invalid literal/length code"),
                  (k = l.avail_in - b),
                  (k = w >> 3 < k ? w >> 3 : k),
                  (b += k),
                  (p -= k),
                  (w -= k << 3),
                  (c.bitb = _),
                  (c.bitk = w),
                  (l.avail_in = b),
                  (l.total_in += p - l.next_in_index),
                  (l.next_in_index = p),
                  (c.write = g),
                  n);
            if (
              ((d += u[R + 2]),
              (d += _ & r[h]),
              (R = 3 * (f + d)),
              0 === (h = u[R]))
            ) {
              (_ >>= u[R + 1]),
                (w -= u[R + 1]),
                (c.window[g++] = u[R + 2]),
                y--;
              break;
            }
          }
        else (_ >>= u[R + 1]), (w -= u[R + 1]), (c.window[g++] = u[R + 2]), y--;
      } while (y >= 258 && b >= 10);
      return (
        (k = l.avail_in - b),
        (k = w >> 3 < k ? w >> 3 : k),
        (b += k),
        (p -= k),
        (w -= k << 3),
        (c.bitb = _),
        (c.bitk = w),
        (l.avail_in = b),
        (l.total_in += p - l.next_in_index),
        (l.next_in_index = p),
        (c.write = g),
        0
      );
    }
    (e.init = function (e, t, n, r, c, l) {
      (i = 0), (_ = e), (w = t), (s = n), (p = r), (o = c), (b = l), (a = null);
    }),
      (e.proc = function (e, y, x) {
        let m,
          k,
          v,
          A,
          R,
          U,
          E,
          S = 0,
          z = 0,
          D = 0;
        for (
          D = y.next_in_index,
            A = y.avail_in,
            S = e.bitb,
            z = e.bitk,
            R = e.write,
            U = R < e.read ? e.read - R - 1 : e.end - R;
          ;

        )
          switch (i) {
            case 0:
              if (
                U >= 258 &&
                A >= 10 &&
                ((e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                (x = g(_, w, s, p, o, b, e, y)),
                (D = y.next_in_index),
                (A = y.avail_in),
                (S = e.bitb),
                (z = e.bitk),
                (R = e.write),
                (U = R < e.read ? e.read - R - 1 : e.end - R),
                0 != x)
              ) {
                i = 1 == x ? 7 : 9;
                break;
              }
              (d = _), (a = s), (l = p), (i = 1);
            case 1:
              for (m = d; z < m; ) {
                if (0 === A)
                  return (
                    (e.bitb = S),
                    (e.bitk = z),
                    (y.avail_in = A),
                    (y.total_in += D - y.next_in_index),
                    (y.next_in_index = D),
                    (e.write = R),
                    e.inflate_flush(y, x)
                  );
                (x = 0), A--, (S |= (255 & y.read_byte(D++)) << z), (z += 8);
              }
              if (
                ((k = 3 * (l + (S & r[m]))),
                (S >>>= a[k + 1]),
                (z -= a[k + 1]),
                (v = a[k]),
                0 === v)
              ) {
                (u = a[k + 2]), (i = 6);
                break;
              }
              if (0 != (16 & v)) {
                (f = 15 & v), (c = a[k + 2]), (i = 2);
                break;
              }
              if (0 == (64 & v)) {
                (d = v), (l = k / 3 + a[k + 2]);
                break;
              }
              if (0 != (32 & v)) {
                i = 7;
                break;
              }
              return (
                (i = 9),
                (y.msg = "invalid literal/length code"),
                (x = n),
                (e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                e.inflate_flush(y, x)
              );
            case 2:
              for (m = f; z < m; ) {
                if (0 === A)
                  return (
                    (e.bitb = S),
                    (e.bitk = z),
                    (y.avail_in = A),
                    (y.total_in += D - y.next_in_index),
                    (y.next_in_index = D),
                    (e.write = R),
                    e.inflate_flush(y, x)
                  );
                (x = 0), A--, (S |= (255 & y.read_byte(D++)) << z), (z += 8);
              }
              (c += S & r[m]),
                (S >>= m),
                (z -= m),
                (d = w),
                (a = o),
                (l = b),
                (i = 3);
            case 3:
              for (m = d; z < m; ) {
                if (0 === A)
                  return (
                    (e.bitb = S),
                    (e.bitk = z),
                    (y.avail_in = A),
                    (y.total_in += D - y.next_in_index),
                    (y.next_in_index = D),
                    (e.write = R),
                    e.inflate_flush(y, x)
                  );
                (x = 0), A--, (S |= (255 & y.read_byte(D++)) << z), (z += 8);
              }
              if (
                ((k = 3 * (l + (S & r[m]))),
                (S >>= a[k + 1]),
                (z -= a[k + 1]),
                (v = a[k]),
                0 != (16 & v))
              ) {
                (f = 15 & v), (h = a[k + 2]), (i = 4);
                break;
              }
              if (0 == (64 & v)) {
                (d = v), (l = k / 3 + a[k + 2]);
                break;
              }
              return (
                (i = 9),
                (y.msg = "invalid distance code"),
                (x = n),
                (e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                e.inflate_flush(y, x)
              );
            case 4:
              for (m = f; z < m; ) {
                if (0 === A)
                  return (
                    (e.bitb = S),
                    (e.bitk = z),
                    (y.avail_in = A),
                    (y.total_in += D - y.next_in_index),
                    (y.next_in_index = D),
                    (e.write = R),
                    e.inflate_flush(y, x)
                  );
                (x = 0), A--, (S |= (255 & y.read_byte(D++)) << z), (z += 8);
              }
              (h += S & r[m]), (S >>= m), (z -= m), (i = 5);
            case 5:
              for (E = R - h; E < 0; ) E += e.end;
              for (; 0 !== c; ) {
                if (
                  0 === U &&
                  (R == e.end &&
                    0 !== e.read &&
                    ((R = 0), (U = R < e.read ? e.read - R - 1 : e.end - R)),
                  0 === U &&
                    ((e.write = R),
                    (x = e.inflate_flush(y, x)),
                    (R = e.write),
                    (U = R < e.read ? e.read - R - 1 : e.end - R),
                    R == e.end &&
                      0 !== e.read &&
                      ((R = 0), (U = R < e.read ? e.read - R - 1 : e.end - R)),
                    0 === U))
                )
                  return (
                    (e.bitb = S),
                    (e.bitk = z),
                    (y.avail_in = A),
                    (y.total_in += D - y.next_in_index),
                    (y.next_in_index = D),
                    (e.write = R),
                    e.inflate_flush(y, x)
                  );
                (e.window[R++] = e.window[E++]),
                  U--,
                  E == e.end && (E = 0),
                  c--;
              }
              i = 0;
              break;
            case 6:
              if (
                0 === U &&
                (R == e.end &&
                  0 !== e.read &&
                  ((R = 0), (U = R < e.read ? e.read - R - 1 : e.end - R)),
                0 === U &&
                  ((e.write = R),
                  (x = e.inflate_flush(y, x)),
                  (R = e.write),
                  (U = R < e.read ? e.read - R - 1 : e.end - R),
                  R == e.end &&
                    0 !== e.read &&
                    ((R = 0), (U = R < e.read ? e.read - R - 1 : e.end - R)),
                  0 === U))
              )
                return (
                  (e.bitb = S),
                  (e.bitk = z),
                  (y.avail_in = A),
                  (y.total_in += D - y.next_in_index),
                  (y.next_in_index = D),
                  (e.write = R),
                  e.inflate_flush(y, x)
                );
              (x = 0), (e.window[R++] = u), U--, (i = 0);
              break;
            case 7:
              if (
                (z > 7 && ((z -= 8), A++, D--),
                (e.write = R),
                (x = e.inflate_flush(y, x)),
                (R = e.write),
                (U = R < e.read ? e.read - R - 1 : e.end - R),
                e.read != e.write)
              )
                return (
                  (e.bitb = S),
                  (e.bitk = z),
                  (y.avail_in = A),
                  (y.total_in += D - y.next_in_index),
                  (y.next_in_index = D),
                  (e.write = R),
                  e.inflate_flush(y, x)
                );
              i = 8;
            case 8:
              return (
                (x = 1),
                (e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                e.inflate_flush(y, x)
              );
            case 9:
              return (
                (x = n),
                (e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                e.inflate_flush(y, x)
              );
            default:
              return (
                (x = t),
                (e.bitb = S),
                (e.bitk = z),
                (y.avail_in = A),
                (y.total_in += D - y.next_in_index),
                (y.next_in_index = D),
                (e.write = R),
                e.inflate_flush(y, x)
              );
          }
      }),
      (e.free = function () {});
  }
  const _ = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  function w(e, a) {
    const s = this;
    let o,
      c = 0,
      l = 0,
      d = 0,
      u = 0;
    const w = [0],
      p = [0],
      b = new h();
    let g = 0,
      y = new Int32Array(4320);
    const x = new f();
    (s.bitk = 0),
      (s.bitb = 0),
      (s.window = new Uint8Array(a)),
      (s.end = a),
      (s.read = 0),
      (s.write = 0),
      (s.reset = function (e, t) {
        t && (t[0] = 0),
          6 == c && b.free(e),
          (c = 0),
          (s.bitk = 0),
          (s.bitb = 0),
          (s.read = s.write = 0);
      }),
      s.reset(e, null),
      (s.inflate_flush = function (e, t) {
        let n, r, a;
        return (
          (r = e.next_out_index),
          (a = s.read),
          (n = (a <= s.write ? s.write : s.end) - a),
          n > e.avail_out && (n = e.avail_out),
          0 !== n && t == i && (t = 0),
          (e.avail_out -= n),
          (e.total_out += n),
          e.next_out.set(s.window.subarray(a, a + n), r),
          (r += n),
          (a += n),
          a == s.end &&
            ((a = 0),
            s.write == s.end && (s.write = 0),
            (n = s.write - a),
            n > e.avail_out && (n = e.avail_out),
            0 !== n && t == i && (t = 0),
            (e.avail_out -= n),
            (e.total_out += n),
            e.next_out.set(s.window.subarray(a, a + n), r),
            (r += n),
            (a += n)),
          (e.next_out_index = r),
          (s.read = a),
          t
        );
      }),
      (s.proc = function (e, i) {
        let a, h, m, k, v, A, R, U;
        for (
          k = e.next_in_index,
            v = e.avail_in,
            h = s.bitb,
            m = s.bitk,
            A = s.write,
            R = A < s.read ? s.read - A - 1 : s.end - A;
          ;

        ) {
          let E, S, z, D, T, F, C, O;
          switch (c) {
            case 0:
              for (; m < 3; ) {
                if (0 === v)
                  return (
                    (s.bitb = h),
                    (s.bitk = m),
                    (e.avail_in = v),
                    (e.total_in += k - e.next_in_index),
                    (e.next_in_index = k),
                    (s.write = A),
                    s.inflate_flush(e, i)
                  );
                (i = 0), v--, (h |= (255 & e.read_byte(k++)) << m), (m += 8);
              }
              switch (((a = 7 & h), (g = 1 & a), a >>> 1)) {
                case 0:
                  (h >>>= 3),
                    (m -= 3),
                    (a = 7 & m),
                    (h >>>= a),
                    (m -= a),
                    (c = 1);
                  break;
                case 1:
                  (E = []),
                    (S = []),
                    (z = [[]]),
                    (D = [[]]),
                    f.inflate_trees_fixed(E, S, z, D),
                    b.init(E[0], S[0], z[0], 0, D[0], 0),
                    (h >>>= 3),
                    (m -= 3),
                    (c = 6);
                  break;
                case 2:
                  (h >>>= 3), (m -= 3), (c = 3);
                  break;
                case 3:
                  return (
                    (h >>>= 3),
                    (m -= 3),
                    (c = 9),
                    (e.msg = "invalid block type"),
                    (i = n),
                    (s.bitb = h),
                    (s.bitk = m),
                    (e.avail_in = v),
                    (e.total_in += k - e.next_in_index),
                    (e.next_in_index = k),
                    (s.write = A),
                    s.inflate_flush(e, i)
                  );
              }
              break;
            case 1:
              for (; m < 32; ) {
                if (0 === v)
                  return (
                    (s.bitb = h),
                    (s.bitk = m),
                    (e.avail_in = v),
                    (e.total_in += k - e.next_in_index),
                    (e.next_in_index = k),
                    (s.write = A),
                    s.inflate_flush(e, i)
                  );
                (i = 0), v--, (h |= (255 & e.read_byte(k++)) << m), (m += 8);
              }
              if (((~h >>> 16) & 65535) != (65535 & h))
                return (
                  (c = 9),
                  (e.msg = "invalid stored block lengths"),
                  (i = n),
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              (l = 65535 & h), (h = m = 0), (c = 0 !== l ? 2 : 0 !== g ? 7 : 0);
              break;
            case 2:
              if (0 === v)
                return (
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              if (
                0 === R &&
                (A == s.end &&
                  0 !== s.read &&
                  ((A = 0), (R = A < s.read ? s.read - A - 1 : s.end - A)),
                0 === R &&
                  ((s.write = A),
                  (i = s.inflate_flush(e, i)),
                  (A = s.write),
                  (R = A < s.read ? s.read - A - 1 : s.end - A),
                  A == s.end &&
                    0 !== s.read &&
                    ((A = 0), (R = A < s.read ? s.read - A - 1 : s.end - A)),
                  0 === R))
              )
                return (
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              if (
                ((i = 0),
                (a = l),
                a > v && (a = v),
                a > R && (a = R),
                s.window.set(e.read_buf(k, a), A),
                (k += a),
                (v -= a),
                (A += a),
                (R -= a),
                0 != (l -= a))
              )
                break;
              c = 0 !== g ? 7 : 0;
              break;
            case 3:
              for (; m < 14; ) {
                if (0 === v)
                  return (
                    (s.bitb = h),
                    (s.bitk = m),
                    (e.avail_in = v),
                    (e.total_in += k - e.next_in_index),
                    (e.next_in_index = k),
                    (s.write = A),
                    s.inflate_flush(e, i)
                  );
                (i = 0), v--, (h |= (255 & e.read_byte(k++)) << m), (m += 8);
              }
              if (((d = a = 16383 & h), (31 & a) > 29 || ((a >> 5) & 31) > 29))
                return (
                  (c = 9),
                  (e.msg = "too many length or distance symbols"),
                  (i = n),
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              if (((a = 258 + (31 & a) + ((a >> 5) & 31)), !o || o.length < a))
                o = [];
              else for (U = 0; U < a; U++) o[U] = 0;
              (h >>>= 14), (m -= 14), (u = 0), (c = 4);
            case 4:
              for (; u < 4 + (d >>> 10); ) {
                for (; m < 3; ) {
                  if (0 === v)
                    return (
                      (s.bitb = h),
                      (s.bitk = m),
                      (e.avail_in = v),
                      (e.total_in += k - e.next_in_index),
                      (e.next_in_index = k),
                      (s.write = A),
                      s.inflate_flush(e, i)
                    );
                  (i = 0), v--, (h |= (255 & e.read_byte(k++)) << m), (m += 8);
                }
                (o[_[u++]] = 7 & h), (h >>>= 3), (m -= 3);
              }
              for (; u < 19; ) o[_[u++]] = 0;
              if (
                ((w[0] = 7), (a = x.inflate_trees_bits(o, w, p, y, e)), 0 != a)
              )
                return (
                  (i = a) == n && ((o = null), (c = 9)),
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              (u = 0), (c = 5);
            case 5:
              for (; (a = d), !(u >= 258 + (31 & a) + ((a >> 5) & 31)); ) {
                let t, l;
                for (a = w[0]; m < a; ) {
                  if (0 === v)
                    return (
                      (s.bitb = h),
                      (s.bitk = m),
                      (e.avail_in = v),
                      (e.total_in += k - e.next_in_index),
                      (e.next_in_index = k),
                      (s.write = A),
                      s.inflate_flush(e, i)
                    );
                  (i = 0), v--, (h |= (255 & e.read_byte(k++)) << m), (m += 8);
                }
                if (
                  ((a = y[3 * (p[0] + (h & r[a])) + 1]),
                  (l = y[3 * (p[0] + (h & r[a])) + 2]),
                  l < 16)
                )
                  (h >>>= a), (m -= a), (o[u++] = l);
                else {
                  for (
                    U = 18 == l ? 7 : l - 14, t = 18 == l ? 11 : 3;
                    m < a + U;

                  ) {
                    if (0 === v)
                      return (
                        (s.bitb = h),
                        (s.bitk = m),
                        (e.avail_in = v),
                        (e.total_in += k - e.next_in_index),
                        (e.next_in_index = k),
                        (s.write = A),
                        s.inflate_flush(e, i)
                      );
                    (i = 0),
                      v--,
                      (h |= (255 & e.read_byte(k++)) << m),
                      (m += 8);
                  }
                  if (
                    ((h >>>= a),
                    (m -= a),
                    (t += h & r[U]),
                    (h >>>= U),
                    (m -= U),
                    (U = u),
                    (a = d),
                    U + t > 258 + (31 & a) + ((a >> 5) & 31) ||
                      (16 == l && U < 1))
                  )
                    return (
                      (o = null),
                      (c = 9),
                      (e.msg = "invalid bit length repeat"),
                      (i = n),
                      (s.bitb = h),
                      (s.bitk = m),
                      (e.avail_in = v),
                      (e.total_in += k - e.next_in_index),
                      (e.next_in_index = k),
                      (s.write = A),
                      s.inflate_flush(e, i)
                    );
                  l = 16 == l ? o[U - 1] : 0;
                  do {
                    o[U++] = l;
                  } while (0 != --t);
                  u = U;
                }
              }
              if (
                ((p[0] = -1),
                (T = []),
                (F = []),
                (C = []),
                (O = []),
                (T[0] = 9),
                (F[0] = 6),
                (a = d),
                (a = x.inflate_trees_dynamic(
                  257 + (31 & a),
                  1 + ((a >> 5) & 31),
                  o,
                  T,
                  F,
                  C,
                  O,
                  y,
                  e
                )),
                0 != a)
              )
                return (
                  a == n && ((o = null), (c = 9)),
                  (i = a),
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              b.init(T[0], F[0], y, C[0], y, O[0]), (c = 6);
            case 6:
              if (
                ((s.bitb = h),
                (s.bitk = m),
                (e.avail_in = v),
                (e.total_in += k - e.next_in_index),
                (e.next_in_index = k),
                (s.write = A),
                1 != (i = b.proc(s, e, i)))
              )
                return s.inflate_flush(e, i);
              if (
                ((i = 0),
                b.free(e),
                (k = e.next_in_index),
                (v = e.avail_in),
                (h = s.bitb),
                (m = s.bitk),
                (A = s.write),
                (R = A < s.read ? s.read - A - 1 : s.end - A),
                0 === g)
              ) {
                c = 0;
                break;
              }
              c = 7;
            case 7:
              if (
                ((s.write = A),
                (i = s.inflate_flush(e, i)),
                (A = s.write),
                (R = A < s.read ? s.read - A - 1 : s.end - A),
                s.read != s.write)
              )
                return (
                  (s.bitb = h),
                  (s.bitk = m),
                  (e.avail_in = v),
                  (e.total_in += k - e.next_in_index),
                  (e.next_in_index = k),
                  (s.write = A),
                  s.inflate_flush(e, i)
                );
              c = 8;
            case 8:
              return (
                (i = 1),
                (s.bitb = h),
                (s.bitk = m),
                (e.avail_in = v),
                (e.total_in += k - e.next_in_index),
                (e.next_in_index = k),
                (s.write = A),
                s.inflate_flush(e, i)
              );
            case 9:
              return (
                (i = n),
                (s.bitb = h),
                (s.bitk = m),
                (e.avail_in = v),
                (e.total_in += k - e.next_in_index),
                (e.next_in_index = k),
                (s.write = A),
                s.inflate_flush(e, i)
              );
            default:
              return (
                (i = t),
                (s.bitb = h),
                (s.bitk = m),
                (e.avail_in = v),
                (e.total_in += k - e.next_in_index),
                (e.next_in_index = k),
                (s.write = A),
                s.inflate_flush(e, i)
              );
          }
        }
      }),
      (s.free = function (e) {
        s.reset(e, null), (s.window = null), (y = null);
      }),
      (s.set_dictionary = function (e, t, n) {
        s.window.set(e.subarray(t, t + n), 0), (s.read = s.write = n);
      }),
      (s.sync_point = function () {
        return 1 == c ? 1 : 0;
      });
  }
  const p = 13,
    b = [0, 0, 255, 255];
  function g() {
    const e = this;
    function r(e) {
      return e && e.istate
        ? ((e.total_in = e.total_out = 0),
          (e.msg = null),
          (e.istate.mode = 7),
          e.istate.blocks.reset(e, null),
          0)
        : t;
    }
    (e.mode = 0),
      (e.method = 0),
      (e.was = [0]),
      (e.need = 0),
      (e.marker = 0),
      (e.wbits = 0),
      (e.inflateEnd = function (t) {
        return e.blocks && e.blocks.free(t), (e.blocks = null), 0;
      }),
      (e.inflateInit = function (n, i) {
        return (
          (n.msg = null),
          (e.blocks = null),
          i < 8 || i > 15
            ? (e.inflateEnd(n), t)
            : ((e.wbits = i), (n.istate.blocks = new w(n, 1 << i)), r(n), 0)
        );
      }),
      (e.inflate = function (e, r) {
        let a, s;
        if (!e || !e.istate || !e.next_in) return t;
        const o = e.istate;
        for (r = 4 == r ? i : 0, a = i; ; )
          switch (o.mode) {
            case 0:
              if (0 === e.avail_in) return a;
              if (
                ((a = r),
                e.avail_in--,
                e.total_in++,
                8 != (15 & (o.method = e.read_byte(e.next_in_index++))))
              ) {
                (o.mode = p),
                  (e.msg = "unknown compression method"),
                  (o.marker = 5);
                break;
              }
              if (8 + (o.method >> 4) > o.wbits) {
                (o.mode = p), (e.msg = "invalid window size"), (o.marker = 5);
                break;
              }
              o.mode = 1;
            case 1:
              if (0 === e.avail_in) return a;
              if (
                ((a = r),
                e.avail_in--,
                e.total_in++,
                (s = 255 & e.read_byte(e.next_in_index++)),
                ((o.method << 8) + s) % 31 != 0)
              ) {
                (o.mode = p),
                  (e.msg = "incorrect header check"),
                  (o.marker = 5);
                break;
              }
              if (0 == (32 & s)) {
                o.mode = 7;
                break;
              }
              o.mode = 2;
            case 2:
              if (0 === e.avail_in) return a;
              (a = r),
                e.avail_in--,
                e.total_in++,
                (o.need =
                  ((255 & e.read_byte(e.next_in_index++)) << 24) & 4278190080),
                (o.mode = 3);
            case 3:
              if (0 === e.avail_in) return a;
              (a = r),
                e.avail_in--,
                e.total_in++,
                (o.need +=
                  ((255 & e.read_byte(e.next_in_index++)) << 16) & 16711680),
                (o.mode = 4);
            case 4:
              if (0 === e.avail_in) return a;
              (a = r),
                e.avail_in--,
                e.total_in++,
                (o.need +=
                  ((255 & e.read_byte(e.next_in_index++)) << 8) & 65280),
                (o.mode = 5);
            case 5:
              return 0 === e.avail_in
                ? a
                : ((a = r),
                  e.avail_in--,
                  e.total_in++,
                  (o.need += 255 & e.read_byte(e.next_in_index++)),
                  (o.mode = 6),
                  2);
            case 6:
              return (
                (o.mode = p), (e.msg = "need dictionary"), (o.marker = 0), t
              );
            case 7:
              if (((a = o.blocks.proc(e, a)), a == n)) {
                (o.mode = p), (o.marker = 0);
                break;
              }
              if ((0 == a && (a = r), 1 != a)) return a;
              (a = r), o.blocks.reset(e, o.was), (o.mode = 12);
            case 12:
              return 1;
            case p:
              return n;
            default:
              return t;
          }
      }),
      (e.inflateSetDictionary = function (e, n, i) {
        let r = 0,
          a = i;
        if (!e || !e.istate || 6 != e.istate.mode) return t;
        const s = e.istate;
        return (
          a >= 1 << s.wbits && ((a = (1 << s.wbits) - 1), (r = i - a)),
          s.blocks.set_dictionary(n, r, a),
          (s.mode = 7),
          0
        );
      }),
      (e.inflateSync = function (e) {
        let a, s, o, c, l;
        if (!e || !e.istate) return t;
        const d = e.istate;
        if (
          (d.mode != p && ((d.mode = p), (d.marker = 0)),
          0 === (a = e.avail_in))
        )
          return i;
        for (s = e.next_in_index, o = d.marker; 0 !== a && o < 4; )
          e.read_byte(s) == b[o] ? o++ : (o = 0 !== e.read_byte(s) ? 0 : 4 - o),
            s++,
            a--;
        return (
          (e.total_in += s - e.next_in_index),
          (e.next_in_index = s),
          (e.avail_in = a),
          (d.marker = o),
          4 != o
            ? n
            : ((c = e.total_in),
              (l = e.total_out),
              r(e),
              (e.total_in = c),
              (e.total_out = l),
              (d.mode = 7),
              0)
        );
      }),
      (e.inflateSyncPoint = function (e) {
        return e && e.istate && e.istate.blocks
          ? e.istate.blocks.sync_point()
          : t;
      });
  }
  function y() {}
  y.prototype = {
    inflateInit: function (e) {
      const t = this;
      return (t.istate = new g()), e || (e = 15), t.istate.inflateInit(t, e);
    },
    inflate: function (e) {
      const n = this;
      return n.istate ? n.istate.inflate(n, e) : t;
    },
    inflateEnd: function () {
      const e = this;
      if (!e.istate) return t;
      const n = e.istate.inflateEnd(e);
      return (e.istate = null), n;
    },
    inflateSync: function () {
      const e = this;
      return e.istate ? e.istate.inflateSync(e) : t;
    },
    inflateSetDictionary: function (e, n) {
      const i = this;
      return i.istate ? i.istate.inflateSetDictionary(i, e, n) : t;
    },
    read_byte: function (e) {
      return this.next_in[e];
    },
    read_buf: function (e, t) {
      return this.next_in.subarray(e, e + t);
    },
  };
  const x = {
      chunkSize: 524288,
      maxWorkers:
        ("undefined" != typeof navigator && navigator.hardwareConcurrency) || 2,
      terminateWorkerTimeout: 5e3,
      useWebWorkers: !0,
      workerScripts: void 0,
    },
    m = Object.assign({}, x);
  function k(e) {
    if (
      (void 0 !== e.chunkSize && (m.chunkSize = e.chunkSize),
      void 0 !== e.maxWorkers && (m.maxWorkers = e.maxWorkers),
      void 0 !== e.terminateWorkerTimeout &&
        (m.terminateWorkerTimeout = e.terminateWorkerTimeout),
      void 0 !== e.useWebWorkers && (m.useWebWorkers = e.useWebWorkers),
      void 0 !== e.Deflate && (m.Deflate = e.Deflate),
      void 0 !== e.Inflate && (m.Inflate = e.Inflate),
      void 0 !== e.workerScripts)
    ) {
      if (e.workerScripts.deflate) {
        if (!Array.isArray(e.workerScripts.deflate))
          throw new Error("workerScripts.deflate must be an array");
        m.workerScripts || (m.workerScripts = {}),
          (m.workerScripts.deflate = e.workerScripts.deflate);
      }
      if (e.workerScripts.inflate) {
        if (!Array.isArray(e.workerScripts.inflate))
          throw new Error("workerScripts.inflate must be an array");
        m.workerScripts || (m.workerScripts = {}),
          (m.workerScripts.inflate = e.workerScripts.inflate);
      }
    }
  }
  const v = "Abort error";
  function A(e, t) {
    if (e && e.aborted) throw (t.flush(), new Error(v));
  }
  async function R(e, t) {
    return t.length && (await e.writeUint8Array(t)), t.length;
  }
  const U = "HTTP error ",
    E = "HTTP Range not supported",
    S = "text/plain",
    z = "GET",
    D = "bytes";
  class T {
    constructor() {
      this.size = 0;
    }
    init() {
      this.initialized = !0;
    }
  }
  class F extends T {}
  class C extends T {
    writeUint8Array(e) {
      this.size += e.length;
    }
  }
  class O extends F {
    constructor(e) {
      super(), (this.blob = e), (this.size = e.size);
    }
    async readUint8Array(e, t) {
      if (this.blob.arrayBuffer)
        return new Uint8Array(await this.blob.slice(e, e + t).arrayBuffer());
      {
        const n = new FileReader();
        return new Promise((i, r) => {
          (n.onload = (e) => i(new Uint8Array(e.target.result))),
            (n.onerror = () => r(n.error)),
            n.readAsArrayBuffer(this.blob.slice(e, e + t));
        });
      }
    }
  }
  class I extends F {
    constructor(e, t) {
      super(),
        (this.url = e),
        (this.preventHeadRequest = t.preventHeadRequest),
        (this.useRangeHeader = t.useRangeHeader),
        (this.forceRangeRequests = t.forceRangeRequests),
        (this.options = Object.assign({}, t)),
        delete this.options.preventHeadRequest,
        delete this.options.useRangeHeader,
        delete this.options.forceRangeRequests,
        delete this.options.useXHR;
    }
    async init() {
      super.init(), await W(this, V, j);
    }
    async readUint8Array(e, t) {
      return B(this, e, t, V, j);
    }
  }
  class M extends F {
    constructor(e, t) {
      super(),
        (this.url = e),
        (this.preventHeadRequest = t.preventHeadRequest),
        (this.useRangeHeader = t.useRangeHeader),
        (this.forceRangeRequests = t.forceRangeRequests),
        (this.options = t);
    }
    async init() {
      super.init(), await W(this, G, N);
    }
    async readUint8Array(e, t) {
      return B(this, e, t, G, N);
    }
  }
  async function W(e, t, n) {
    if (
      (function (e) {
        if ("undefined" != typeof document) {
          const t = document.createElement("a");
          return (t.href = e), "http:" == t.protocol || "https:" == t.protocol;
        }
        return /^https?:\/\//i.test(e);
      })(e.url) &&
      (e.useRangeHeader || e.forceRangeRequests)
    ) {
      const i = await t(z, e, L(e));
      if (!e.forceRangeRequests && i.headers.get("Accept-Ranges") != D)
        throw new Error(E);
      {
        let r;
        const a = i.headers.get("Content-Range");
        if (a) {
          const e = a.trim().split(/\s*\/\s*/);
          if (e.length) {
            const t = e[1];
            t && "*" != t && (r = Number(t));
          }
        }
        void 0 === r ? await q(e, t, n) : (e.size = r);
      }
    } else await q(e, t, n);
  }
  async function B(e, t, n, i, r) {
    if (e.useRangeHeader || e.forceRangeRequests) {
      const r = await i(z, e, L(e, t, n));
      if (206 != r.status) throw new Error(E);
      return new Uint8Array(await r.arrayBuffer());
    }
    return (
      e.data || (await r(e, e.options)),
      new Uint8Array(e.data.subarray(t, t + n))
    );
  }
  function L(e, t = 0, n = 1) {
    return Object.assign({}, H(e), { Range: "bytes=" + t + "-" + (t + n - 1) });
  }
  function H(e) {
    let t = e.options.headers;
    if (t) return Symbol.iterator in t ? Object.fromEntries(t) : t;
  }
  async function j(e) {
    await P(e, V);
  }
  async function N(e) {
    await P(e, G);
  }
  async function P(e, t) {
    const n = await t(z, e, H(e));
    (e.data = new Uint8Array(await n.arrayBuffer())),
      e.size || (e.size = e.data.length);
  }
  async function q(e, t, n) {
    if (e.preventHeadRequest) await n(e, e.options);
    else {
      const i = (await t("HEAD", e, H(e))).headers.get("Content-Length");
      i ? (e.size = Number(i)) : await n(e, e.options);
    }
  }
  async function V(e, { options: t, url: n }, i) {
    const r = await fetch(n, Object.assign({}, t, { method: e, headers: i }));
    if (r.status < 400) return r;
    throw new Error(U + (r.statusText || r.status));
  }
  function G(e, { url: t }, n) {
    return new Promise((i, r) => {
      const a = new XMLHttpRequest();
      if (
        (a.addEventListener(
          "load",
          () => {
            if (a.status < 400) {
              const e = [];
              a
                .getAllResponseHeaders()
                .trim()
                .split(/[\r\n]+/)
                .forEach((t) => {
                  const n = t.trim().split(/\s*:\s*/);
                  (n[0] = n[0]
                    .trim()
                    .replace(/^[a-z]|-[a-z]/g, (e) => e.toUpperCase())),
                    e.push(n);
                }),
                i({
                  status: a.status,
                  arrayBuffer: () => a.response,
                  headers: new Map(e),
                });
            } else r(new Error(U + (a.statusText || a.status)));
          },
          !1
        ),
        a.addEventListener("error", (e) => r(e.detail.error), !1),
        a.open(e, t),
        n)
      )
        for (const e of Object.entries(n)) a.setRequestHeader(e[0], e[1]);
      (a.responseType = "arraybuffer"), a.send();
    });
  }
  class Z extends F {
    constructor(e, t = {}) {
      super(),
        (this.url = e),
        t.useXHR ? (this.reader = new M(e, t)) : (this.reader = new I(e, t));
    }
    set size(e) {}
    get size() {
      return this.reader.size;
    }
    async init() {
      super.init(), await this.reader.init();
    }
    async readUint8Array(e, t) {
      return this.reader.readUint8Array(e, t);
    }
  }
  const K = 4294967295,
    X = 33639248,
    Y = 101075792,
    J =
      "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split(
        ""
      );
  const Q = [];
  for (let e = 0; e < 256; e++) {
    let t = e;
    for (let e = 0; e < 8; e++)
      1 & t ? (t = (t >>> 1) ^ 3988292384) : (t >>>= 1);
    Q[e] = t;
  }
  class $ {
    constructor(e) {
      this.crc = e || -1;
    }
    append(e) {
      let t = 0 | this.crc;
      for (let n = 0, i = 0 | e.length; n < i; n++)
        t = (t >>> 8) ^ Q[255 & (t ^ e[n])];
      this.crc = t;
    }
    get() {
      return ~this.crc;
    }
  }
  const ee = {
      concat(e, t) {
        if (0 === e.length || 0 === t.length) return e.concat(t);
        const n = e[e.length - 1],
          i = ee.getPartial(n);
        return 32 === i
          ? e.concat(t)
          : ee._shiftRight(t, i, 0 | n, e.slice(0, e.length - 1));
      },
      bitLength(e) {
        const t = e.length;
        if (0 === t) return 0;
        const n = e[t - 1];
        return 32 * (t - 1) + ee.getPartial(n);
      },
      clamp(e, t) {
        if (32 * e.length < t) return e;
        const n = (e = e.slice(0, Math.ceil(t / 32))).length;
        return (
          (t &= 31),
          n > 0 &&
            t &&
            (e[n - 1] = ee.partial(t, e[n - 1] & (2147483648 >> (t - 1)), 1)),
          e
        );
      },
      partial: (e, t, n) =>
        32 === e ? t : (n ? 0 | t : t << (32 - e)) + 1099511627776 * e,
      getPartial: (e) => Math.round(e / 1099511627776) || 32,
      _shiftRight(e, t, n, i) {
        for (void 0 === i && (i = []); t >= 32; t -= 32) i.push(n), (n = 0);
        if (0 === t) return i.concat(e);
        for (let r = 0; r < e.length; r++)
          i.push(n | (e[r] >>> t)), (n = e[r] << (32 - t));
        const r = e.length ? e[e.length - 1] : 0,
          a = ee.getPartial(r);
        return i.push(ee.partial((t + a) & 31, t + a > 32 ? n : i.pop(), 1)), i;
      },
    },
    te = {
      bytes: {
        fromBits(e) {
          const t = ee.bitLength(e) / 8,
            n = new Uint8Array(t);
          let i;
          for (let r = 0; r < t; r++)
            0 == (3 & r) && (i = e[r / 4]), (n[r] = i >>> 24), (i <<= 8);
          return n;
        },
        toBits(e) {
          const t = [];
          let n,
            i = 0;
          for (n = 0; n < e.length; n++)
            (i = (i << 8) | e[n]), 3 == (3 & n) && (t.push(i), (i = 0));
          return 3 & n && t.push(ee.partial(8 * (3 & n), i)), t;
        },
      },
    },
    ne = {
      sha1: function (e) {
        e
          ? ((this._h = e._h.slice(0)),
            (this._buffer = e._buffer.slice(0)),
            (this._length = e._length))
          : this.reset();
      },
    };
  ne.sha1.prototype = {
    blockSize: 512,
    reset: function () {
      const e = this;
      return (e._h = this._init.slice(0)), (e._buffer = []), (e._length = 0), e;
    },
    update: function (e) {
      const t = this;
      "string" == typeof e && (e = te.utf8String.toBits(e));
      const n = (t._buffer = ee.concat(t._buffer, e)),
        i = t._length,
        r = (t._length = i + ee.bitLength(e));
      if (r > 9007199254740991)
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      const a = new Uint32Array(n);
      let s = 0;
      for (
        let e = t.blockSize + i - ((t.blockSize + i) & (t.blockSize - 1));
        e <= r;
        e += t.blockSize
      )
        t._block(a.subarray(16 * s, 16 * (s + 1))), (s += 1);
      return n.splice(0, 16 * s), t;
    },
    finalize: function () {
      const e = this;
      let t = e._buffer;
      const n = e._h;
      t = ee.concat(t, [ee.partial(1, 1)]);
      for (let e = t.length + 2; 15 & e; e++) t.push(0);
      for (
        t.push(Math.floor(e._length / 4294967296)), t.push(0 | e._length);
        t.length;

      )
        e._block(t.splice(0, 16));
      return e.reset(), n;
    },
    _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
    _key: [1518500249, 1859775393, 2400959708, 3395469782],
    _f: function (e, t, n, i) {
      return e <= 19
        ? (t & n) | (~t & i)
        : e <= 39
        ? t ^ n ^ i
        : e <= 59
        ? (t & n) | (t & i) | (n & i)
        : e <= 79
        ? t ^ n ^ i
        : void 0;
    },
    _S: function (e, t) {
      return (t << e) | (t >>> (32 - e));
    },
    _block: function (e) {
      const t = this,
        n = t._h,
        i = Array(80);
      for (let t = 0; t < 16; t++) i[t] = e[t];
      let r = n[0],
        a = n[1],
        s = n[2],
        o = n[3],
        c = n[4];
      for (let e = 0; e <= 79; e++) {
        e >= 16 &&
          (i[e] = t._S(1, i[e - 3] ^ i[e - 8] ^ i[e - 14] ^ i[e - 16]));
        const n =
          (t._S(5, r) +
            t._f(e, a, s, o) +
            c +
            i[e] +
            t._key[Math.floor(e / 20)]) |
          0;
        (c = o), (o = s), (s = t._S(30, a)), (a = r), (r = n);
      }
      (n[0] = (n[0] + r) | 0),
        (n[1] = (n[1] + a) | 0),
        (n[2] = (n[2] + s) | 0),
        (n[3] = (n[3] + o) | 0),
        (n[4] = (n[4] + c) | 0);
    },
  };
  const ie = {
      aes: class {
        constructor(e) {
          const t = this;
          (t._tables = [
            [[], [], [], [], []],
            [[], [], [], [], []],
          ]),
            t._tables[0][0][0] || t._precompute();
          const n = t._tables[0][4],
            i = t._tables[1],
            r = e.length;
          let a,
            s,
            o,
            c = 1;
          if (4 !== r && 6 !== r && 8 !== r)
            throw new Error("invalid aes key size");
          for (
            t._key = [(s = e.slice(0)), (o = [])], a = r;
            a < 4 * r + 28;
            a++
          ) {
            let e = s[a - 1];
            (a % r == 0 || (8 === r && a % r == 4)) &&
              ((e =
                (n[e >>> 24] << 24) ^
                (n[(e >> 16) & 255] << 16) ^
                (n[(e >> 8) & 255] << 8) ^
                n[255 & e]),
              a % r == 0 &&
                ((e = (e << 8) ^ (e >>> 24) ^ (c << 24)),
                (c = (c << 1) ^ (283 * (c >> 7))))),
              (s[a] = s[a - r] ^ e);
          }
          for (let e = 0; a; e++, a--) {
            const t = s[3 & e ? a : a - 4];
            o[e] =
              a <= 4 || e < 4
                ? t
                : i[0][n[t >>> 24]] ^
                  i[1][n[(t >> 16) & 255]] ^
                  i[2][n[(t >> 8) & 255]] ^
                  i[3][n[255 & t]];
          }
        }
        encrypt(e) {
          return this._crypt(e, 0);
        }
        decrypt(e) {
          return this._crypt(e, 1);
        }
        _precompute() {
          const e = this._tables[0],
            t = this._tables[1],
            n = e[4],
            i = t[4],
            r = [],
            a = [];
          let s, o, c, l;
          for (let e = 0; e < 256; e++)
            a[(r[e] = (e << 1) ^ (283 * (e >> 7))) ^ e] = e;
          for (let d = (s = 0); !n[d]; d ^= o || 1, s = a[s] || 1) {
            let a = s ^ (s << 1) ^ (s << 2) ^ (s << 3) ^ (s << 4);
            (a = (a >> 8) ^ (255 & a) ^ 99),
              (n[d] = a),
              (i[a] = d),
              (l = r[(c = r[(o = r[d])])]);
            let u = (16843009 * l) ^ (65537 * c) ^ (257 * o) ^ (16843008 * d),
              f = (257 * r[a]) ^ (16843008 * a);
            for (let n = 0; n < 4; n++)
              (e[n][d] = f = (f << 24) ^ (f >>> 8)),
                (t[n][a] = u = (u << 24) ^ (u >>> 8));
          }
          for (let n = 0; n < 5; n++)
            (e[n] = e[n].slice(0)), (t[n] = t[n].slice(0));
        }
        _crypt(e, t) {
          if (4 !== e.length) throw new Error("invalid aes block size");
          const n = this._key[t],
            i = n.length / 4 - 2,
            r = [0, 0, 0, 0],
            a = this._tables[t],
            s = a[0],
            o = a[1],
            c = a[2],
            l = a[3],
            d = a[4];
          let u,
            f,
            h,
            _ = e[0] ^ n[0],
            w = e[t ? 3 : 1] ^ n[1],
            p = e[2] ^ n[2],
            b = e[t ? 1 : 3] ^ n[3],
            g = 4;
          for (let e = 0; e < i; e++)
            (u =
              s[_ >>> 24] ^
              o[(w >> 16) & 255] ^
              c[(p >> 8) & 255] ^
              l[255 & b] ^
              n[g]),
              (f =
                s[w >>> 24] ^
                o[(p >> 16) & 255] ^
                c[(b >> 8) & 255] ^
                l[255 & _] ^
                n[g + 1]),
              (h =
                s[p >>> 24] ^
                o[(b >> 16) & 255] ^
                c[(_ >> 8) & 255] ^
                l[255 & w] ^
                n[g + 2]),
              (b =
                s[b >>> 24] ^
                o[(_ >> 16) & 255] ^
                c[(w >> 8) & 255] ^
                l[255 & p] ^
                n[g + 3]),
              (g += 4),
              (_ = u),
              (w = f),
              (p = h);
          for (let e = 0; e < 4; e++)
            (r[t ? 3 & -e : e] =
              (d[_ >>> 24] << 24) ^
              (d[(w >> 16) & 255] << 16) ^
              (d[(p >> 8) & 255] << 8) ^
              d[255 & b] ^
              n[g++]),
              (u = _),
              (_ = w),
              (w = p),
              (p = b),
              (b = u);
          return r;
        }
      },
    },
    re = {
      ctrGladman: class {
        constructor(e, t) {
          (this._prf = e), (this._initIv = t), (this._iv = t);
        }
        reset() {
          this._iv = this._initIv;
        }
        update(e) {
          return this.calculate(this._prf, e, this._iv);
        }
        incWord(e) {
          if (255 == ((e >> 24) & 255)) {
            let t = (e >> 16) & 255,
              n = (e >> 8) & 255,
              i = 255 & e;
            255 === t
              ? ((t = 0),
                255 === n ? ((n = 0), 255 === i ? (i = 0) : ++i) : ++n)
              : ++t,
              (e = 0),
              (e += t << 16),
              (e += n << 8),
              (e += i);
          } else e += 1 << 24;
          return e;
        }
        incCounter(e) {
          0 === (e[0] = this.incWord(e[0])) && (e[1] = this.incWord(e[1]));
        }
        calculate(e, t, n) {
          let i;
          if (!(i = t.length)) return [];
          const r = ee.bitLength(t);
          for (let r = 0; r < i; r += 4) {
            this.incCounter(n);
            const i = e.encrypt(n);
            (t[r] ^= i[0]),
              (t[r + 1] ^= i[1]),
              (t[r + 2] ^= i[2]),
              (t[r + 3] ^= i[3]);
          }
          return ee.clamp(t, r);
        }
      },
    },
    ae = {
      hmacSha1: class {
        constructor(e) {
          const t = this,
            n = (t._hash = ne.sha1),
            i = [[], []],
            r = n.prototype.blockSize / 32;
          (t._baseHash = [new n(), new n()]), e.length > r && (e = n.hash(e));
          for (let t = 0; t < r; t++)
            (i[0][t] = 909522486 ^ e[t]), (i[1][t] = 1549556828 ^ e[t]);
          t._baseHash[0].update(i[0]),
            t._baseHash[1].update(i[1]),
            (t._resultHash = new n(t._baseHash[0]));
        }
        reset() {
          const e = this;
          (e._resultHash = new e._hash(e._baseHash[0])), (e._updated = !1);
        }
        update(e) {
          (this._updated = !0), this._resultHash.update(e);
        }
        digest() {
          const e = this,
            t = e._resultHash.finalize(),
            n = new e._hash(e._baseHash[1]).update(t).finalize();
          return e.reset(), n;
        }
      },
    },
    se = "Invalid pasword",
    oe = 16,
    ce = { name: "PBKDF2" },
    le = Object.assign({ hash: { name: "HMAC" } }, ce),
    de = Object.assign({ iterations: 1e3, hash: { name: "SHA-1" } }, ce),
    ue = ["deriveBits"],
    fe = [8, 12, 16],
    he = [16, 24, 32],
    _e = 10,
    we = [0, 0, 0, 0],
    pe = te.bytes,
    be = ie.aes,
    ge = re.ctrGladman,
    ye = ae.hmacSha1;
  class xe {
    constructor(e, t, n) {
      Object.assign(this, {
        password: e,
        signed: t,
        strength: n - 1,
        pendingInput: new Uint8Array(0),
      });
    }
    async append(e) {
      const t = this;
      if (t.password) {
        const n = Re(e, 0, fe[t.strength] + 2);
        await (async function (e, t, n) {
          await ve(e, n, Re(t, 0, fe[e.strength]));
          const i = Re(t, fe[e.strength]),
            r = e.keys.passwordVerification;
          if (r[0] != i[0] || r[1] != i[1]) throw new Error(se);
        })(t, n, t.password),
          (t.password = null),
          (t.aesCtrGladman = new ge(new be(t.keys.key), Array.from(we))),
          (t.hmac = new ye(t.keys.authentication)),
          (e = Re(e, fe[t.strength] + 2));
      }
      return ke(
        t,
        e,
        new Uint8Array(e.length - _e - ((e.length - _e) % oe)),
        0,
        _e,
        !0
      );
    }
    flush() {
      const e = this,
        t = e.pendingInput,
        n = Re(t, 0, t.length - _e),
        i = Re(t, t.length - _e);
      let r = new Uint8Array(0);
      if (n.length) {
        const t = pe.toBits(n);
        e.hmac.update(t);
        const i = e.aesCtrGladman.update(t);
        r = pe.fromBits(i);
      }
      let a = !0;
      if (e.signed) {
        const t = Re(pe.fromBits(e.hmac.digest()), 0, _e);
        for (let e = 0; e < _e; e++) t[e] != i[e] && (a = !1);
      }
      return { valid: a, data: r };
    }
  }
  class me {
    constructor(e, t) {
      Object.assign(this, {
        password: e,
        strength: t - 1,
        pendingInput: new Uint8Array(0),
      });
    }
    async append(e) {
      const t = this;
      let n = new Uint8Array(0);
      t.password &&
        ((n = await (async function (e, t) {
          const n = crypto.getRandomValues(new Uint8Array(fe[e.strength]));
          return await ve(e, t, n), Ae(n, e.keys.passwordVerification);
        })(t, t.password)),
        (t.password = null),
        (t.aesCtrGladman = new ge(new be(t.keys.key), Array.from(we))),
        (t.hmac = new ye(t.keys.authentication)));
      const i = new Uint8Array(n.length + e.length - (e.length % oe));
      return i.set(n, 0), ke(t, e, i, n.length, 0);
    }
    flush() {
      const e = this;
      let t = new Uint8Array(0);
      if (e.pendingInput.length) {
        const n = e.aesCtrGladman.update(pe.toBits(e.pendingInput));
        e.hmac.update(n), (t = pe.fromBits(n));
      }
      const n = Re(pe.fromBits(e.hmac.digest()), 0, _e);
      return { data: Ae(t, n), signature: n };
    }
  }
  function ke(e, t, n, i, r, a) {
    const s = t.length - r;
    let o;
    for (
      e.pendingInput.length &&
        ((t = Ae(e.pendingInput, t)),
        (n = (function (e, t) {
          if (t && t > e.length) {
            const n = e;
            (e = new Uint8Array(t)).set(n, 0);
          }
          return e;
        })(n, s - (s % oe)))),
        o = 0;
      o <= s - oe;
      o += oe
    ) {
      const r = pe.toBits(Re(t, o, o + oe));
      a && e.hmac.update(r);
      const s = e.aesCtrGladman.update(r);
      a || e.hmac.update(s), n.set(pe.fromBits(s), o + i);
    }
    return (e.pendingInput = Re(t, o)), n;
  }
  async function ve(e, t, n) {
    const i = new TextEncoder().encode(t),
      r = await crypto.subtle.importKey("raw", i, le, !1, ue),
      a = await crypto.subtle.deriveBits(
        Object.assign({ salt: n }, de),
        r,
        8 * (2 * he[e.strength] + 2)
      ),
      s = new Uint8Array(a);
    e.keys = {
      key: pe.toBits(Re(s, 0, he[e.strength])),
      authentication: pe.toBits(Re(s, he[e.strength], 2 * he[e.strength])),
      passwordVerification: Re(s, 2 * he[e.strength]),
    };
  }
  function Ae(e, t) {
    let n = e;
    return (
      e.length + t.length &&
        ((n = new Uint8Array(e.length + t.length)),
        n.set(e, 0),
        n.set(t, e.length)),
      n
    );
  }
  function Re(e, t, n) {
    return e.subarray(t, n);
  }
  const Ue = 12;
  class Ee {
    constructor(e, t) {
      Object.assign(this, { password: e, passwordVerification: t }),
        Te(this, e);
    }
    append(e) {
      const t = this;
      if (t.password) {
        const n = ze(t, e.subarray(0, Ue));
        if (((t.password = null), n[11] != t.passwordVerification))
          throw new Error(se);
        e = e.subarray(Ue);
      }
      return ze(t, e);
    }
    flush() {
      return { valid: !0, data: new Uint8Array(0) };
    }
  }
  class Se {
    constructor(e, t) {
      Object.assign(this, { password: e, passwordVerification: t }),
        Te(this, e);
    }
    append(e) {
      const t = this;
      let n, i;
      if (t.password) {
        t.password = null;
        const r = crypto.getRandomValues(new Uint8Array(Ue));
        (r[11] = t.passwordVerification),
          (n = new Uint8Array(e.length + r.length)),
          n.set(De(t, r), 0),
          (i = Ue);
      } else (n = new Uint8Array(e.length)), (i = 0);
      return n.set(De(t, e), i), n;
    }
    flush() {
      return { data: new Uint8Array(0) };
    }
  }
  function ze(e, t) {
    const n = new Uint8Array(t.length);
    for (let i = 0; i < t.length; i++) (n[i] = Ce(e) ^ t[i]), Fe(e, n[i]);
    return n;
  }
  function De(e, t) {
    const n = new Uint8Array(t.length);
    for (let i = 0; i < t.length; i++) (n[i] = Ce(e) ^ t[i]), Fe(e, t[i]);
    return n;
  }
  function Te(e, t) {
    (e.keys = [305419896, 591751049, 878082192]),
      (e.crcKey0 = new $(e.keys[0])),
      (e.crcKey2 = new $(e.keys[2]));
    for (let n = 0; n < t.length; n++) Fe(e, t.charCodeAt(n));
  }
  function Fe(e, t) {
    e.crcKey0.append([t]),
      (e.keys[0] = ~e.crcKey0.get()),
      (e.keys[1] = Ie(e.keys[1] + Oe(e.keys[0]))),
      (e.keys[1] = Ie(Math.imul(e.keys[1], 134775813) + 1)),
      e.crcKey2.append([e.keys[1] >>> 24]),
      (e.keys[2] = ~e.crcKey2.get());
  }
  function Ce(e) {
    const t = 2 | e.keys[2];
    return Oe(Math.imul(t, 1 ^ t) >>> 8);
  }
  function Oe(e) {
    return 255 & e;
  }
  function Ie(e) {
    return 4294967295 & e;
  }
  const Me = "inflate",
    We = "Invalid signature";
  class Be {
    constructor(
      e,
      {
        signature: t,
        password: n,
        signed: i,
        compressed: r,
        zipCrypto: a,
        passwordVerification: s,
        encryptionStrength: o,
      },
      { chunkSize: c }
    ) {
      const l = Boolean(n);
      Object.assign(this, {
        signature: t,
        encrypted: l,
        signed: i,
        compressed: r,
        inflate: r && new e({ chunkSize: c }),
        crc32: i && new $(),
        zipCrypto: a,
        decrypt: l && a ? new Ee(n, s) : new xe(n, i, o),
      });
    }
    async append(e) {
      const t = this;
      return (
        t.encrypted && e.length && (e = await t.decrypt.append(e)),
        t.compressed && e.length && (e = await t.inflate.append(e)),
        (!t.encrypted || t.zipCrypto) &&
          t.signed &&
          e.length &&
          t.crc32.append(e),
        e
      );
    }
    async flush() {
      const e = this;
      let t,
        n = new Uint8Array(0);
      if (e.encrypted) {
        const t = e.decrypt.flush();
        if (!t.valid) throw new Error(We);
        n = t.data;
      }
      if ((!e.encrypted || e.zipCrypto) && e.signed) {
        const n = new DataView(new Uint8Array(4).buffer);
        if (
          ((t = e.crc32.get()),
          n.setUint32(0, t),
          e.signature != n.getUint32(0, !1))
        )
          throw new Error(We);
      }
      return (
        e.compressed &&
          ((n = (await e.inflate.append(n)) || new Uint8Array(0)),
          await e.inflate.flush()),
        { data: n, signature: t }
      );
    }
  }
  class Le {
    constructor(
      e,
      {
        encrypted: t,
        signed: n,
        compressed: i,
        level: r,
        zipCrypto: a,
        password: s,
        passwordVerification: o,
        encryptionStrength: c,
      },
      { chunkSize: l }
    ) {
      Object.assign(this, {
        encrypted: t,
        signed: n,
        compressed: i,
        deflate: i && new e({ level: r || 5, chunkSize: l }),
        crc32: n && new $(),
        zipCrypto: a,
        encrypt: t && a ? new Se(s, o) : new me(s, c),
      });
    }
    async append(e) {
      const t = this;
      let n = e;
      return (
        t.compressed && e.length && (n = await t.deflate.append(e)),
        t.encrypted && n.length && (n = await t.encrypt.append(n)),
        (!t.encrypted || t.zipCrypto) &&
          t.signed &&
          e.length &&
          t.crc32.append(e),
        n
      );
    }
    async flush() {
      const e = this;
      let t,
        n = new Uint8Array(0);
      if (
        (e.compressed && (n = (await e.deflate.flush()) || new Uint8Array(0)),
        e.encrypted)
      ) {
        n = await e.encrypt.append(n);
        const i = e.encrypt.flush();
        t = i.signature;
        const r = new Uint8Array(n.length + i.data.length);
        r.set(n, 0), r.set(i.data, n.length), (n = r);
      }
      return (
        (e.encrypted && !e.zipCrypto) || !e.signed || (t = e.crc32.get()),
        { data: n, signature: t }
      );
    }
  }
  const He = "init",
    je = "append",
    Ne = "flush",
    Pe = "message";
  let qe = !0;
  var Ve = (e, t, n, i, r, a, s) => (
    Object.assign(e, {
      busy: !0,
      codecConstructor: t,
      options: Object.assign({}, n),
      scripts: s,
      terminate() {
        e.worker && !e.busy && (e.worker.terminate(), (e.interface = null));
      },
      onTaskFinished() {
        (e.busy = !1), r(e);
      },
    }),
    a
      ? (function (e, t) {
          let n;
          const i = { type: "module" };
          if (!e.interface) {
            if (qe)
              try {
                e.worker = r();
              } catch (t) {
                (qe = !1), (e.worker = r(i));
              }
            else e.worker = r(i);
            e.worker.addEventListener(Pe, o, !1),
              (e.interface = {
                append: (e) => a({ type: je, data: e }),
                flush: () => a({ type: Ne }),
              });
          }
          return e.interface;
          function r(t = {}) {
            return new Worker(
              new URL(
                e.scripts[0],
                "undefined" == typeof document && "undefined" == typeof location
                  ? new (require("url").URL)("file:" + __filename).href
                  : "undefined" == typeof document
                  ? location.href
                  : (document.currentScript && document.currentScript.src) ||
                    new URL("zip-no-worker-inflate.min.js", document.baseURI)
                      .href
              ),
              t
            );
          }
          async function a(i) {
            if (!n) {
              const n = e.options,
                i = e.scripts.slice(1);
              await s({
                scripts: i,
                type: He,
                options: n,
                config: { chunkSize: t.chunkSize },
              });
            }
            return s(i);
          }
          function s(t) {
            const i = e.worker,
              r = new Promise((e, t) => (n = { resolve: e, reject: t }));
            try {
              if (t.data)
                try {
                  (t.data = t.data.buffer), i.postMessage(t, [t.data]);
                } catch (e) {
                  i.postMessage(t);
                }
              else i.postMessage(t);
            } catch (t) {
              n.reject(t), (n = null), e.onTaskFinished();
            }
            return r;
          }
          function o(t) {
            const i = t.data;
            if (n) {
              const t = i.error,
                r = i.type;
              if (t) {
                const i = new Error(t.message);
                (i.stack = t.stack),
                  n.reject(i),
                  (n = null),
                  e.onTaskFinished();
              } else if (r == He || r == Ne || r == je) {
                const t = i.data;
                r == Ne
                  ? (n.resolve({
                      data: new Uint8Array(t),
                      signature: i.signature,
                    }),
                    (n = null),
                    e.onTaskFinished())
                  : n.resolve(t && new Uint8Array(t));
              }
            }
          }
        })(e, i)
      : (function (e, t) {
          const n = (function (e, t, n) {
            return t.codecType.startsWith("deflate")
              ? new Le(e, t, n)
              : t.codecType.startsWith(Me)
              ? new Be(e, t, n)
              : void 0;
          })(e.codecConstructor, e.options, t);
          return {
            async append(t) {
              try {
                return await n.append(t);
              } catch (t) {
                throw (e.onTaskFinished(), t);
              }
            },
            async flush() {
              try {
                return await n.flush();
              } finally {
                e.onTaskFinished();
              }
            },
          };
        })(e, i)
  );
  let Ge = [],
    Ze = [];
  function Ke(e) {
    e.terminateTimeout &&
      (clearTimeout(e.terminateTimeout), (e.terminateTimeout = null));
  }
  const Xe = [
    "filename",
    "rawFilename",
    "directory",
    "encrypted",
    "compressedSize",
    "uncompressedSize",
    "lastModDate",
    "rawLastModDate",
    "comment",
    "rawComment",
    "signature",
    "extraField",
    "rawExtraField",
    "bitFlag",
    "extraFieldZip64",
    "extraFieldUnicodePath",
    "extraFieldUnicodeComment",
    "extraFieldAES",
    "filenameUTF8",
    "commentUTF8",
    "offset",
    "zip64",
    "compressionMethod",
    "extraFieldNTFS",
    "lastAccessDate",
    "creationDate",
    "extraFieldExtendedTimestamp",
    "version",
    "versionMadeBy",
    "msDosCompatible",
    "internalFileAttribute",
    "externalFileAttribute",
  ];
  class Ye {
    constructor(e) {
      Xe.forEach((t) => (this[t] = e[t]));
    }
  }
  const Je = "File format is not recognized",
    Qe = "End of central directory not found",
    $e = "End of Zip64 central directory not found",
    et = "End of Zip64 central directory locator not found",
    tt = "Central directory header not found",
    nt = "Local file header not found",
    it = "Zip64 extra field not found",
    rt = "File contains encrypted entry",
    at = "Encryption method not supported",
    st = "Compression method not supported",
    ot = "utf-8",
    ct = ["uncompressedSize", "compressedSize", "offset"];
  class lt {
    constructor(e, t, n) {
      Object.assign(this, { reader: e, config: t, options: n });
    }
    async getData(e, t, n = {}) {
      const i = this,
        {
          reader: r,
          offset: a,
          extraFieldAES: s,
          compressionMethod: o,
          config: c,
          bitFlag: l,
          signature: d,
          rawLastModDate: u,
          compressedSize: f,
        } = i,
        h = (i.localDirectory = {});
      r.initialized || (await r.init());
      let _ = await kt(r, a, 30);
      const w = mt(_);
      let p = ht(i, n, "password");
      if (((p = p && p.length && p), s && 99 != s.originalCompressionMethod))
        throw new Error(st);
      if (0 != o && 8 != o) throw new Error(st);
      if (67324752 != yt(w, 0)) throw new Error(nt);
      dt(h, w, 4),
        (_ = await kt(r, a, 30 + h.filenameLength + h.extraFieldLength)),
        (h.rawExtraField = _.subarray(30 + h.filenameLength)),
        ut(i, h, w, 4),
        (t.lastAccessDate = h.lastAccessDate),
        (t.creationDate = h.creationDate);
      const b = i.encrypted && h.encrypted,
        g = b && !s;
      if (b) {
        if (!g && void 0 === s.strength) throw new Error(at);
        if (!p) throw new Error(rt);
      }
      const y = await (function (e, t, n) {
        const i =
            !(!t.compressed && !t.signed && !t.encrypted) &&
            (t.useWebWorkers ||
              (void 0 === t.useWebWorkers && n.useWebWorkers)),
          r = i && n.workerScripts ? n.workerScripts[t.codecType] : [];
        if (Ge.length < n.maxWorkers) {
          const s = {};
          return Ge.push(s), Ve(s, e, t, n, a, i, r);
        }
        {
          const s = Ge.find((e) => !e.busy);
          return s
            ? (Ke(s), Ve(s, e, t, n, a, i, r))
            : new Promise((n) =>
                Ze.push({
                  resolve: n,
                  codecConstructor: e,
                  options: t,
                  webWorker: i,
                  scripts: r,
                })
              );
        }
        function a(e) {
          if (Ze.length) {
            const [
              {
                resolve: t,
                codecConstructor: i,
                options: r,
                webWorker: s,
                scripts: o,
              },
            ] = Ze.splice(0, 1);
            t(Ve(e, i, r, n, a, s, o));
          } else
            e.worker
              ? (Ke(e),
                Number.isFinite(n.terminateWorkerTimeout) &&
                  n.terminateWorkerTimeout >= 0 &&
                  (e.terminateTimeout = setTimeout(() => {
                    (Ge = Ge.filter((t) => t != e)), e.terminate();
                  }, n.terminateWorkerTimeout)))
              : (Ge = Ge.filter((t) => t != e));
        }
      })(
        c.Inflate,
        {
          codecType: Me,
          password: p,
          zipCrypto: g,
          encryptionStrength: s && s.strength,
          signed: ht(i, n, "checkSignature"),
          passwordVerification:
            g && (l.dataDescriptor ? (u >>> 8) & 255 : (d >>> 24) & 255),
          signature: d,
          compressed: 0 != o,
          encrypted: b,
          useWebWorkers: ht(i, n, "useWebWorkers"),
        },
        c
      );
      e.initialized || (await e.init());
      const x = ht(i, n, "signal"),
        m = a + 30 + h.filenameLength + h.extraFieldLength;
      return (
        await (async function (e, t, n, i, r, a, s) {
          const o = Math.max(a.chunkSize, 64);
          return (async function a(c = 0, l = 0) {
            const d = s.signal;
            if (c < r) {
              A(d, e);
              const u = await t.readUint8Array(c + i, Math.min(o, r - c)),
                f = u.length;
              A(d, e);
              const h = await e.append(u);
              if ((A(d, e), (l += await R(n, h)), s.onprogress))
                try {
                  s.onprogress(c + f, r);
                } catch (e) {}
              return a(c + o, l);
            }
            {
              const t = await e.flush();
              return (
                (l += await R(n, t.data)), { signature: t.signature, length: l }
              );
            }
          })();
        })(y, r, e, m, f, c, { onprogress: n.onprogress, signal: x }),
        e.getData()
      );
    }
  }
  function dt(e, t, n) {
    const i = (e.rawBitFlag = gt(t, n + 2)),
      r = 1 == (1 & i),
      a = yt(t, n + 6);
    Object.assign(e, {
      encrypted: r,
      version: gt(t, n),
      bitFlag: {
        level: (6 & i) >> 1,
        dataDescriptor: 8 == (8 & i),
        languageEncodingFlag: 2048 == (2048 & i),
      },
      rawLastModDate: a,
      lastModDate: wt(a),
      filenameLength: gt(t, n + 22),
      extraFieldLength: gt(t, n + 24),
    });
  }
  function ut(e, t, n, i) {
    const r = t.rawExtraField,
      a = (t.extraField = new Map()),
      s = mt(new Uint8Array(r));
    let o = 0;
    try {
      for (; o < r.length; ) {
        const e = gt(s, o),
          t = gt(s, o + 2);
        a.set(e, { type: e, data: r.slice(o + 4, o + 4 + t) }), (o += 4 + t);
      }
    } catch (e) {}
    const c = gt(n, i + 4);
    (t.signature = yt(n, i + 10)),
      (t.uncompressedSize = yt(n, i + 18)),
      (t.compressedSize = yt(n, i + 14));
    const l = a.get(1);
    l &&
      (!(function (e, t) {
        t.zip64 = !0;
        const n = mt(e.data);
        e.values = [];
        for (let t = 0; t < Math.floor(e.data.length / 8); t++)
          e.values.push(xt(n, 0 + 8 * t));
        const i = ct.filter((e) => t[e] == K);
        for (let t = 0; t < i.length; t++) e[i[t]] = e.values[t];
        ct.forEach((n) => {
          if (t[n] == K) {
            if (void 0 === e[n]) throw new Error(it);
            t[n] = e[n];
          }
        });
      })(l, t),
      (t.extraFieldZip64 = l));
    const d = a.get(28789);
    d &&
      (ft(d, "filename", "rawFilename", t, e), (t.extraFieldUnicodePath = d));
    const u = a.get(25461);
    u &&
      (ft(u, "comment", "rawComment", t, e), (t.extraFieldUnicodeComment = u));
    const f = a.get(39169);
    f
      ? (!(function (e, t, n) {
          const i = mt(e.data);
          (e.vendorVersion = bt(i, 0)), (e.vendorId = bt(i, 2));
          const r = bt(i, 4);
          (e.strength = r),
            (e.originalCompressionMethod = n),
            (t.compressionMethod = e.compressionMethod = gt(i, 5));
        })(f, t, c),
        (t.extraFieldAES = f))
      : (t.compressionMethod = c);
    const h = a.get(10);
    h &&
      (!(function (e, t) {
        const n = mt(e.data);
        let i,
          r = 4;
        try {
          for (; r < e.data.length && !i; ) {
            const t = gt(n, r),
              a = gt(n, r + 2);
            1 == t && (i = e.data.slice(r + 4, r + 4 + a)), (r += 4 + a);
          }
        } catch (e) {}
        try {
          if (i && 24 == i.length) {
            const n = mt(i),
              r = n.getBigUint64(0, !0),
              a = n.getBigUint64(8, !0),
              s = n.getBigUint64(16, !0);
            Object.assign(e, {
              rawLastModDate: r,
              rawLastAccessDate: a,
              rawCreationDate: s,
            });
            const o = pt(r),
              c = pt(a),
              l = { lastModDate: o, lastAccessDate: c, creationDate: pt(s) };
            Object.assign(e, l), Object.assign(t, l);
          }
        } catch (e) {}
      })(h, t),
      (t.extraFieldNTFS = h));
    const _ = a.get(21589);
    _ &&
      (!(function (e, t) {
        const n = mt(e.data),
          i = bt(n, 0),
          r = [],
          a = [];
        1 == (1 & i) && (r.push("lastModDate"), a.push("rawLastModDate"));
        2 == (2 & i) && (r.push("lastAccessDate"), a.push("rawLastAccessDate"));
        4 == (4 & i) && (r.push("creationDate"), a.push("rawCreationDate"));
        let s = 1;
        r.forEach((i, r) => {
          if (e.data.length >= s + 4) {
            const o = yt(n, s);
            t[i] = e[i] = new Date(1e3 * o);
            const c = a[r];
            e[c] = o;
          }
          s += 4;
        });
      })(_, t),
      (t.extraFieldExtendedTimestamp = _));
  }
  function ft(e, t, n, i, r) {
    const a = mt(e.data);
    (e.version = bt(a, 0)), (e.signature = yt(a, 1));
    const s = new $();
    s.append(r[n]);
    const o = mt(new Uint8Array(4));
    o.setUint32(0, s.get(), !0),
      (e[t] = new TextDecoder().decode(e.data.subarray(5))),
      (e.valid = !r.bitFlag.languageEncodingFlag && e.signature == yt(o, 0)),
      e.valid && ((i[t] = e[t]), (i[t + "UTF8"] = !0));
  }
  function ht(e, t, n) {
    return void 0 === t[n] ? e.options[n] : t[n];
  }
  function _t(e, t) {
    return t && "cp437" != t.trim().toLowerCase()
      ? new TextDecoder(t).decode(e)
      : ((e) => {
          let t = "";
          for (let n = 0; n < e.length; n++) t += J[e[n]];
          return t;
        })(e);
  }
  function wt(e) {
    const t = (4294901760 & e) >> 16,
      n = 65535 & e;
    try {
      return new Date(
        1980 + ((65024 & t) >> 9),
        ((480 & t) >> 5) - 1,
        31 & t,
        (63488 & n) >> 11,
        (2016 & n) >> 5,
        2 * (31 & n),
        0
      );
    } catch (e) {}
  }
  function pt(e) {
    return new Date(Number(e / BigInt(1e4) - BigInt(116444736e5)));
  }
  function bt(e, t) {
    return e.getUint8(t);
  }
  function gt(e, t) {
    return e.getUint16(t, !0);
  }
  function yt(e, t) {
    return e.getUint32(t, !0);
  }
  function xt(e, t) {
    return Number(e.getBigUint64(t, !0));
  }
  function mt(e) {
    return new DataView(e.buffer);
  }
  function kt(e, t, n) {
    return e.readUint8Array(t, n);
  }
  k({
    Inflate: function (e) {
      const t = new y(),
        n = e && e.chunkSize ? Math.floor(2 * e.chunkSize) : 131072,
        r = new Uint8Array(n);
      let a = !1;
      t.inflateInit(),
        (t.next_out = r),
        (this.append = function (e, s) {
          const o = [];
          let c,
            l,
            d = 0,
            u = 0,
            f = 0;
          if (0 !== e.length) {
            (t.next_in_index = 0), (t.next_in = e), (t.avail_in = e.length);
            do {
              if (
                ((t.next_out_index = 0),
                (t.avail_out = n),
                0 !== t.avail_in || a || ((t.next_in_index = 0), (a = !0)),
                (c = t.inflate(0)),
                a && c === i)
              ) {
                if (0 !== t.avail_in) throw new Error("inflating: bad input");
              } else if (0 !== c && 1 !== c)
                throw new Error("inflating: " + t.msg);
              if ((a || 1 === c) && t.avail_in === e.length)
                throw new Error("inflating: bad input");
              t.next_out_index &&
                (t.next_out_index === n
                  ? o.push(new Uint8Array(r))
                  : o.push(r.slice(0, t.next_out_index))),
                (f += t.next_out_index),
                s &&
                  t.next_in_index > 0 &&
                  t.next_in_index != d &&
                  (s(t.next_in_index), (d = t.next_in_index));
            } while (t.avail_in > 0 || 0 === t.avail_out);
            return (
              o.length > 1
                ? ((l = new Uint8Array(f)),
                  o.forEach(function (e) {
                    l.set(e, u), (u += e.length);
                  }))
                : (l = o[0] || new Uint8Array(0)),
              l
            );
          }
        }),
        (this.flush = function () {
          t.inflateEnd();
        });
    },
  }),
    (e.BlobReader = O),
    (e.BlobWriter = class extends C {
      constructor(e) {
        super(), (this.contentType = e), (this.arrayBuffers = []);
      }
      async writeUint8Array(e) {
        super.writeUint8Array(e), this.arrayBuffers.push(e.buffer);
      }
      getData() {
        return (
          this.blob ||
            (this.blob = new Blob(this.arrayBuffers, {
              type: this.contentType,
            })),
          this.blob
        );
      }
    }),
    (e.Data64URIReader = class extends F {
      constructor(e) {
        super(), (this.dataURI = e);
        let t = e.length;
        for (; "=" == e.charAt(t - 1); ) t--;
        (this.dataStart = e.indexOf(",") + 1),
          (this.size = Math.floor(0.75 * (t - this.dataStart)));
      }
      async readUint8Array(e, t) {
        const n = new Uint8Array(t),
          i = 4 * Math.floor(e / 3),
          r = atob(
            this.dataURI.substring(
              i + this.dataStart,
              4 * Math.ceil((e + t) / 3) + this.dataStart
            )
          ),
          a = e - 3 * Math.floor(i / 4);
        for (let e = a; e < a + t; e++) n[e - a] = r.charCodeAt(e);
        return n;
      }
    }),
    (e.Data64URIWriter = class extends C {
      constructor(e) {
        super(),
          (this.data = "data:" + (e || "") + ";base64,"),
          (this.pending = []);
      }
      async writeUint8Array(e) {
        super.writeUint8Array(e);
        let t = 0,
          n = this.pending;
        const i = this.pending.length;
        for (
          this.pending = "", t = 0;
          t < 3 * Math.floor((i + e.length) / 3) - i;
          t++
        )
          n += String.fromCharCode(e[t]);
        for (; t < e.length; t++) this.pending += String.fromCharCode(e[t]);
        n.length > 2 ? (this.data += btoa(n)) : (this.pending = n);
      }
      getData() {
        return this.data + btoa(this.pending);
      }
    }),
    (e.ERR_ABORT = v),
    (e.ERR_BAD_FORMAT = Je),
    (e.ERR_CENTRAL_DIRECTORY_NOT_FOUND = tt),
    (e.ERR_ENCRYPTED = rt),
    (e.ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = et),
    (e.ERR_EOCDR_NOT_FOUND = Qe),
    (e.ERR_EOCDR_ZIP64_NOT_FOUND = $e),
    (e.ERR_EXTRAFIELD_ZIP64_NOT_FOUND = it),
    (e.ERR_HTTP_RANGE = E),
    (e.ERR_INVALID_PASSWORD = se),
    (e.ERR_INVALID_SIGNATURE = We),
    (e.ERR_LOCAL_FILE_HEADER_NOT_FOUND = nt),
    (e.ERR_UNSUPPORTED_COMPRESSION = st),
    (e.ERR_UNSUPPORTED_ENCRYPTION = at),
    (e.HttpRangeReader = class extends Z {
      constructor(e, t = {}) {
        (t.useRangeHeader = !0), super(e, t);
      }
    }),
    (e.HttpReader = Z),
    (e.Reader = F),
    (e.TextReader = class extends F {
      constructor(e) {
        super(), (this.blobReader = new O(new Blob([e], { type: S })));
      }
      async init() {
        super.init(),
          this.blobReader.init(),
          (this.size = this.blobReader.size);
      }
      async readUint8Array(e, t) {
        return this.blobReader.readUint8Array(e, t);
      }
    }),
    (e.TextWriter = class extends C {
      constructor(e) {
        super(), (this.encoding = e), (this.blob = new Blob([], { type: S }));
      }
      async writeUint8Array(e) {
        super.writeUint8Array(e),
          (this.blob = new Blob([this.blob, e.buffer], { type: S }));
      }
      getData() {
        if (this.blob.text) return this.blob.text();
        {
          const e = new FileReader();
          return new Promise((t, n) => {
            (e.onload = (e) => t(e.target.result)),
              (e.onerror = () => n(e.error)),
              e.readAsText(this.blob, this.encoding);
          });
        }
      }
    }),
    (e.Uint8ArrayReader = class extends F {
      constructor(e) {
        super(), (this.array = e), (this.size = e.length);
      }
      async readUint8Array(e, t) {
        return this.array.slice(e, e + t);
      }
    }),
    (e.Uint8ArrayWriter = class extends C {
      constructor() {
        super(), (this.array = new Uint8Array(0));
      }
      async writeUint8Array(e) {
        super.writeUint8Array(e);
        const t = this.array;
        (this.array = new Uint8Array(t.length + e.length)),
          this.array.set(t),
          this.array.set(e, t.length);
      }
      getData() {
        return this.array;
      }
    }),
    (e.Writer = C),
    (e.ZipReader = class {
      constructor(e, t = {}) {
        Object.assign(this, { reader: e, options: t, config: m });
      }
      async getEntries(e = {}) {
        const t = this,
          n = t.reader;
        if ((n.initialized || (await n.init()), n.size < 22))
          throw new Error(Je);
        const i = await (async function (e, t, n, i, r) {
          const a = new Uint8Array(4);
          !(function (e, t, n) {
            e.setUint32(t, n, !0);
          })(mt(a), 0, t);
          const s = i + r;
          return (await o(i)) || (await o(Math.min(s, n)));
          async function o(t) {
            const r = n - t,
              s = await kt(e, r, t);
            for (let e = s.length - i; e >= 0; e--)
              if (
                s[e] == a[0] &&
                s[e + 1] == a[1] &&
                s[e + 2] == a[2] &&
                s[e + 3] == a[3]
              )
                return { offset: r + e, buffer: s.slice(e, e + i).buffer };
          }
        })(n, 101010256, n.size, 22, 1048560);
        if (!i) throw new Error(Qe);
        const r = mt(i);
        let a = yt(r, 12),
          s = yt(r, 16),
          o = gt(r, 8),
          c = 0;
        if (s == K || a == K || 65535 == o) {
          const e = mt(await kt(n, i.offset - 20, 20));
          if (117853008 != yt(e, 0)) throw new Error($e);
          s = xt(e, 8);
          let t = await kt(n, s, 56),
            r = mt(t);
          const l = i.offset - 20 - 56;
          if (yt(r, 0) != Y && s != l) {
            const e = s;
            (s = l), (c = s - e), (t = await kt(n, s, 56)), (r = mt(t));
          }
          if (yt(r, 0) != Y) throw new Error(et);
          (o = xt(r, 32)), (a = xt(r, 40)), (s -= a);
        }
        if (s < 0 || s >= n.size) throw new Error(Je);
        let l = 0,
          d = await kt(n, s, a),
          u = mt(d);
        const f = i.offset - a;
        if (yt(u, l) != X && s != f) {
          const e = s;
          (s = f), (c = s - e), (d = await kt(n, s, a)), (u = mt(d));
        }
        if (s < 0 || s >= n.size) throw new Error(Je);
        const h = [];
        for (let i = 0; i < o; i++) {
          const r = new lt(n, t.config, t.options);
          if (yt(u, l) != X) throw new Error(tt);
          dt(r, u, l + 6);
          const a = Boolean(r.bitFlag.languageEncodingFlag),
            s = l + 46,
            f = s + r.filenameLength,
            _ = f + r.extraFieldLength,
            w = gt(u, l + 4),
            p = 0 == (0 & w);
          Object.assign(r, {
            versionMadeBy: w,
            msDosCompatible: p,
            compressedSize: 0,
            uncompressedSize: 0,
            commentLength: gt(u, l + 32),
            directory: p && 16 == (16 & bt(u, l + 38)),
            offset: yt(u, l + 42) + c,
            internalFileAttribute: yt(u, l + 34),
            externalFileAttribute: yt(u, l + 38),
            rawFilename: d.subarray(s, f),
            filenameUTF8: a,
            commentUTF8: a,
            rawExtraField: d.subarray(f, _),
          });
          const b = _ + r.commentLength;
          (r.rawComment = d.subarray(_, b)),
            (r.filename = _t(
              r.rawFilename,
              r.filenameUTF8 ? ot : ht(t, e, "filenameEncoding")
            )),
            (r.comment = _t(
              r.rawComment,
              r.commentUTF8 ? ot : ht(t, e, "commentEncoding")
            )),
            !r.directory && r.filename.endsWith("/") && (r.directory = !0),
            ut(r, r, u, l + 6);
          const g = new Ye(r);
          if (
            ((g.getData = (e, t) => r.getData(e, g, t)),
            h.push(g),
            (l = b),
            e.onprogress)
          )
            try {
              e.onprogress(i + 1, o, new Ye(r));
            } catch (e) {}
        }
        return h;
      }
      async close() {}
    }),
    (e.configure = k),
    (e.getMimeType = function () {
      return "application/octet-stream";
    }),
    Object.defineProperty(e, "__esModule", { value: !0 });
});
